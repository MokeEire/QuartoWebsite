[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Mark Barrett",
    "section": "",
    "text": "I am an analyst with a passion for behavioural science, R, and public policy. This website is for building a data analytics and visualization portfolio, and writing about policy and my research process. My interests include decision-making, governance institutions, and information systems, and particularly areas where these topics coincide."
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "Mark Barrett",
    "section": "Education",
    "text": "Education\nLoyola Marymount University | Los Angeles, CA\nB.S in Economics & Psychology | Aug. 2012 - May 2016"
  },
  {
    "objectID": "about.html#experience",
    "href": "about.html#experience",
    "title": "Mark Barrett",
    "section": "Experience",
    "text": "Experience\nRAND Corporation | Research Assistant | Apr. 2016 - Feb. 2020\nCBRE | Sr. Research Data Analyst | Mar. 2020 - May 2022\nKarl Storz | Sr. Business Analyst | June 2022 - present"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "21 min\n\n\n\n\n\n\nJul 14, 2022\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hi, I’m Mark.",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n\n\n\n\n  \n\n\n\n\n\nUntangling congressional legislative data\n\n\n\n\n\n\nJul 14, 2022\n\n\n21 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/parse-legislative-data.html",
    "href": "posts/parse-legislative-data.html",
    "title": "Parsing XML with R",
    "section": "",
    "text": "Data comes in many forms. You have probably used data formats like Excel spreadsheets, text files, relational databases and if you’re reading this you may have run into files stored in (e)Xtensible Markup Language, or XML. XML is a storage format designed for flexibly transmitting data1 but this flexibility often leads to a bit of a hassle when trying to parse it for use in analytics. This article takes a look at this tricky, but valuable data type, how to use it, and a set of steps for processing XML with R.\nThe impetus for this post was the US government’s congressional data. The US General Post Office collects and provides records of all the bills that pass through congress, including the committees which consider the bill, the legislators who sponsor, or co-sponsor the bill, and any action taken on the bill while it is in congress e.g. votes and debates. I wanted to see what kind of insights we can glean about the legislative structures and context of decision-making that determines the laws that are passed (or not).\nAs always the first step of data analysis is to check if any documentation exists and thankfully govinfo has provided some guidance for how to interpret the data and where its limitations are.\nTo follow along, you can download the sample XML file here. The sample bill (chosen because its contents are instructional for data cleaning) is HR-391: Global Health Security Act of 2021."
  },
  {
    "objectID": "posts/parse-legislative-data.html#parse-the-simple-elements",
    "href": "posts/parse-legislative-data.html#parse-the-simple-elements",
    "title": "Parsing XML with R",
    "section": "Parse the simple elements",
    "text": "Parse the simple elements\nThe simple parts of the data to process are those which are already at the level of observation you want. In our case - at the bill level. These are typically the top-level nodes which only have one piece of data. To select only these nodes we can write a function like the one below. It selects the child nodes, uses xml_length() to select the nodes which have no further child nodes (i.e. singular), and keeps the nodes which are singular and not empty.\n\nCode# Function to select singular child nodes from XML node\nxml_singular_nodes = function(xml_node){\n  # Return child nodes of current node\n  child_nodes = xml_children(xml_node)\n  # Select child nodes with 0 children\n  zero_length_child_nodes = child_nodes[xml_length(child_nodes) == 0]\n  \n  # Keep the nodes which are not empty strings\n  keep(zero_length_child_nodes, ~(xml_text(.) != \"\"))\n}\n\n(singular_nodes = xml_singular_nodes(bill_xml))\n\n{xml_nodeset (10)}\n [1] <billNumber>391</billNumber>\n [2] <createDate>2021-01-22T08:12:10Z</createDate>\n [3] <updateDate>2022-02-09T12:37:52Z</updateDate>\n [4] <originChamber>House</originChamber>\n [5] <billType>HR</billType>\n [6] <introducedDate>2021-01-21</introducedDate>\n [7] <congress>117</congress>\n [8] <constitutionalAuthorityStatementText><![CDATA[<pre>[Congressional Recor ...\n [9] <title>Global Health Security Act of 2021</title>\n[10] <version>1.0.0</version>\n\n\nNow with a nifty combination of as_list(), xml_name(), and flatten_dfc() we can go from XML -> list -> dataframe. The process convert the singular nodes into a list, names them, and flattens each element of the list into a single column of data.\n\nCodebill_df = as_list(singular_nodes) %>% \n  # as_list() doesn't retain element names so we set names ourselves\n  setNames(xml_name(singular_nodes)) %>% \n  flatten_dfc()\n\n\nWhich combines to give us a single row of data:\n\n\n\n\n\n\n\nThis includes the bill title, when it was introduced, what type of bill it is, and which congress introduced it. To combine the data for actions, sponsors, committees, and votes, we need to process them individually."
  },
  {
    "objectID": "posts/parse-legislative-data.html#parse-the-not-so-simple-elements",
    "href": "posts/parse-legislative-data.html#parse-the-not-so-simple-elements",
    "title": "Parsing XML with R",
    "section": "Parse the not-so-simple elements",
    "text": "Parse the not-so-simple elements\nThis is where the majority of the legwork is so if you can comfortably filter out some data4, now’s a good time. There’s no point spending an hour trying to process one particularly difficult bit of information only to realize it isn’t useful to you anyway.\nFor brevity I’ll go through how to process the actions and votes elements, but you can find the code for extracting the full XML file here5.\nActions\nWhat’s in the actions container?\n\nCode(actions_xml = xml_find_all(bill_xml, \"actions/item\"))\n\n{xml_nodeset (14)}\n [1] <item>\\n  <actionDate>2021-07-12</actionDate>\\n  <committees>\\n    <item ...\n [2] <item>\\n  <actionDate>2021-06-28</actionDate>\\n  <actionTime>19:46:03</a ...\n [3] <item>\\n  <actionDate>2021-06-28</actionDate>\\n  <actionTime>19:46:02</a ...\n [4] <item>\\n  <actionDate>2021-06-28</actionDate>\\n  <actionTime>19:46:02</a ...\n [5] <item>\\n  <actionDate>2021-06-28</actionDate>\\n  <actionTime>19:24:39</a ...\n [6] <item>\\n  <actionDate>2021-06-28</actionDate>\\n  <actionTime>15:20:02</a ...\n [7] <item>\\n  <actionDate>2021-06-28</actionDate>\\n  <actionTime>15:05:31</a ...\n [8] <item>\\n  <actionDate>2021-06-28</actionDate>\\n  <actionTime>15:05:26</a ...\n [9] <item>\\n  <actionDate>2021-06-28</actionDate>\\n  <actionTime>15:05:13</a ...\n[10] <item>\\n  <actionDate>2021-03-25</actionDate>\\n  <committees>\\n    <item ...\n[11] <item>\\n  <actionDate>2021-03-25</actionDate>\\n  <committees>\\n    <item ...\n[12] <item>\\n  <actionDate>2021-01-21</actionDate>\\n  <links/>\\n  <text>Refer ...\n[13] <item>\\n  <actionDate>2021-01-21</actionDate>\\n  <links/>\\n  <text>Intro ...\n[14] <item>\\n  <actionDate>2021-01-21</actionDate>\\n  <links/>\\n  <text>Intro ...\n\n\nAnd what does a single action element look like?\n\nCodexml_contents(actions_xml[1])\n\n{xml_nodeset (6)}\n[1] <actionDate>2021-07-12</actionDate>\n[2] <committees>\\n  <item>\\n    <systemCode>ssfr00</systemCode>\\n    <name>Fo ...\n[3] <links/>\n[4] <sourceSystem>\\n  <code>0</code>\\n  <name>Senate</name>\\n</sourceSystem>\n[5] <text>Received in the Senate and Read twice and referred to the Committee ...\n[6] <type>IntroReferral</type>\n\n\nSo this bill has 14 actions recorded on it. We can use as_list() to convert the {xml_nodeset} to a list.\n\nCodeactions_list = as_list(actions_xml)\n\nglimpse(actions_list[[1]])\n\nList of 6\n $ actionDate  :List of 1\n  ..$ : chr \"2021-07-12\"\n $ committees  :List of 1\n  ..$ item:List of 2\n  .. ..$ systemCode:List of 1\n  .. ..$ name      :List of 1\n $ links       : list()\n $ sourceSystem:List of 2\n  ..$ code:List of 1\n  .. ..$ : chr \"0\"\n  ..$ name:List of 1\n  .. ..$ : chr \"Senate\"\n $ text        :List of 1\n  ..$ : chr \"Received in the Senate and Read twice and referred to the Committee on Foreign Relations.\"\n $ type        :List of 1\n  ..$ : chr \"IntroReferral\"\n\n\nIn the individual action container, we can see we have the type, text, and date of the action, a list of committees related to the action, and some elements which are singular and some which are not. To deal with this, we can write a function (or set of functions) like the ones below to process an action:\n\nCode# Helper function: flatten_dfc_rename\n# flatten a list to dataframe and \n# rename the columns with a given prefix\nflatten_dfc_rename = function(list_to_flatten, \n                          name_prefix = \"prefix\"){\n  rename_with(flatten_dfc(list_to_flatten), ~str_c(name_prefix, \"_\", .))\n}\n\n# Function: parse_action\n# Parse actions from list to dataframe\nparse_action = function(action){\n  action %>% \n    # Flatten+rename  sourceSystem elements\n    modify_at(\"sourceSystem\", ~flatten_dfc_rename(.x, \"source\")) %>% \n    # Flatten+rename committees\n    modify_at(\"committees\", function(committee){\n      map_dfr(committee, ~flatten_dfc_rename(.x, \"committee\"))\n    }) %>% \n    # Flatten object to dataframe\n    flatten_dfc() %>% \n    # Add prefix to singular columns\n    rename_with(.fn = ~str_c(\"action_\", .), .cols = -starts_with(\"action\")) %>% \n    janitor::clean_names()\n}\n\n# Parse the first action\nparse_action(actions_list[[1]])\n\n# A tibble: 1 × 7\n  action_date action_committee_system_code action_committee_na… action_source_c…\n  <chr>       <chr>                        <chr>                <chr>           \n1 2021-07-12  ssfr00                       Foreign Relations C… 0               \n# … with 3 more variables: action_source_name <chr>, action_text <chr>,\n#   action_type <chr>\n\n\nUsing the purrr library’s map_*() functions, we can apply this function over all of the items:\n\nCode(actions_df = map_dfr(actions_list, parse_action)) %>% \n  glimpse()\n\nRows: 14\nColumns: 9\n$ action_date                  <chr> \"2021-07-12\", \"2021-06-28\", \"2021-06-28\",…\n$ action_committee_system_code <chr> \"ssfr00\", NA, NA, NA, NA, NA, NA, NA, NA,…\n$ action_committee_name        <chr> \"Foreign Relations Committee\", NA, NA, NA…\n$ action_source_code           <chr> \"0\", \"2\", \"2\", \"9\", \"2\", \"2\", \"2\", \"2\", \"…\n$ action_source_name           <chr> \"Senate\", \"House floor actions\", \"House f…\n$ action_text                  <chr> \"Received in the Senate and Read twice an…\n$ action_type                  <chr> \"IntroReferral\", \"Floor\", \"Floor\", \"Floor…\n$ action_time                  <chr> NA, \"19:46:03\", \"19:46:02\", \"19:46:02\", \"…\n$ action_code                  <chr> NA, \"H38310\", \"H37300\", \"8000\", \"H30000\",…\n\n\nNow if you’re processing a large amount of these data, you may want to be explicit about the data types expected in each column. This is vital when we want to unnest() the actions data and combine many bills’ actions into an actions-level dataset. You can do this using type_convert() , notice the change in column types from the output above.\n\nCode(actions_df = type_convert(actions_df,\n                          col_types = cols(\n                            action_date = col_date(), \n                            action_time = col_time(),\n                            action_committee_systemCode = col_character(), \n                            action_committee_name = col_character(), \n                            action_source_code = col_character(),\n                            action_source_name = col_character(),\n                            action_text = col_character(), \n                            action_type = col_character(), \n                            action_code = col_character()\n                            )\n                          )) %>% \n  glimpse()\n\nRows: 14\nColumns: 9\n$ action_date                  <date> 2021-07-12, 2021-06-28, 2021-06-28, 2021…\n$ action_committee_system_code <chr> \"ssfr00\", NA, NA, NA, NA, NA, NA, NA, NA,…\n$ action_committee_name        <chr> \"Foreign Relations Committee\", NA, NA, NA…\n$ action_source_code           <chr> \"0\", \"2\", \"2\", \"9\", \"2\", \"2\", \"2\", \"2\", \"…\n$ action_source_name           <chr> \"Senate\", \"House floor actions\", \"House f…\n$ action_text                  <chr> \"Received in the Senate and Read twice an…\n$ action_type                  <chr> \"IntroReferral\", \"Floor\", \"Floor\", \"Floor…\n$ action_time                  <time>       NA, 19:46:03, 19:46:02, 19:46:02, …\n$ action_code                  <chr> NA, \"H38310\", \"H37300\", \"8000\", \"H30000\",…\n\n\nTo add these actions data as a list column to bill_df we can simply use dollar assignment.\n\nCodebill_df$actions = list(actions_df)\n\nglimpse(bill_df)\n\nRows: 1\nColumns: 11\n$ billNumber                           <chr> \"391\"\n$ createDate                           <chr> \"2021-01-22T08:12:10Z\"\n$ updateDate                           <chr> \"2022-02-09T12:37:52Z\"\n$ originChamber                        <chr> \"House\"\n$ billType                             <chr> \"HR\"\n$ introducedDate                       <chr> \"2021-01-21\"\n$ congress                             <chr> \"117\"\n$ constitutionalAuthorityStatementText <chr> \"<pre>[Congressional Record Volum…\n$ title                                <chr> \"Global Health Security Act of 20…\n$ version                              <chr> \"1.0.0\"\n$ actions                              <list> [<tbl_df[14 x 9]>]\n\n\nThe remaining sections will be following the same process for different elements, but it can be boiled down to these steps:\n\nExplore the structure\n\n\nGo through any available documentation, and when you read in the XML file you can use functions like xmlParse(), xml_structure(), and xml_contents() .\n\n\nDefine the output\n\n\nConsider what you want the output to look like and think about how it needs to be transformed to match this target.\n\n\n\nProcess a single element (write a function if it gets too complicated)\n\n\nGet one element into the form you want. Writing functions can help you think through the data transformations being applied and make your code easier to read.\n\n\nApply to all elements\n\n\nFocus on processing of the entire file (or the subset of the file you’re interested in). You might want an XML file to return a single row, a single column, or a dataframe of size \\(n\\times k\\). Once you have a single file returned in the format you want, you can combine the outputs of multiple files.\n\n\n\n\n\n\n\nFind the exceptions\n\n\n\nLastly, you will likely run into situations where a node which only seemed to contain a single piece of data has a different structure with multiple sub-elements for other files. This will happen, you’ll go back to the drawing board, design more flexibility in your functions, and understand how process either format.\n\n\nVotes\nVotes are particularly interesting because it provides a more discrete measure of our representatives’ behaviour. Individual votes are stored in the <recordedVotes> container. We can access child elements in XML using a forward slash (this uses a language called XPATH).\n\nCode(bill_recorded_vote_nodes = xml_find_all(bill_xml, \"recordedVotes/recordedVote\")) %>% \n  xml_contents()\n\n{xml_nodeset (7)}\n[1] <rollNumber>188</rollNumber>\n[2] <url>https://clerk.house.gov/evs/2021/roll188.xml</url>\n[3] <fullActionName>Final Passage Under Suspension of the Rules Results</full ...\n[4] <chamber>House</chamber>\n[5] <congress>117</congress>\n[6] <date>2021-06-28T23:46:02Z</date>\n[7] <sessionNumber>1</sessionNumber>\n\n\nYou may have spotted why votes are interesting elements to parse because inside the <url> element we find another XML file!6 Before we dive into that can of worms, I’ll convert the top-level nodes to a list and flatten it into columns. Note we use map_dfr() with votes_list because there could be multiple vote objects.\n\nCode# Coerce nodes to list\nrecorded_votes_list = as_list(bill_recorded_vote_nodes)\n\n(recorded_votes_df = map_dfr(recorded_votes_list, flatten_dfc)) %>% \n  glimpse()\n\nRows: 1\nColumns: 7\n$ rollNumber     <chr> \"188\"\n$ url            <chr> \"https://clerk.house.gov/evs/2021/roll188.xml\"\n$ fullActionName <chr> \"Final Passage Under Suspension of the Rules Results\"\n$ chamber        <chr> \"House\"\n$ congress       <chr> \"117\"\n$ date           <chr> \"2021-06-28T23:46:02Z\"\n$ sessionNumber  <chr> \"1\"\n\n\nNow we want to get the vote roll XML file, so we go back to read_xml() .\n\nCode(vote_roll_xml = read_xml(recorded_votes_df$url))\n\n{xml_document}\n<rollcall-vote>\n[1] <vote-metadata>\\n  <majority>D</majority>\\n  <congress>117</congress>\\n   ...\n[2] <vote-data>\\n  <recorded-vote>\\n    <legislator name-id=\"A000370\" sort-fi ...\n\n\nThere are two main nodes - <vote-metadata> and <vote-data>. How many elements does each node have and what do the structures for these look like?\n\nCode(vote_roll_children = xml_children(vote_roll_xml)) %>% \n  map(xml_contents)\n\n[[1]]\n{xml_nodeset (13)}\n [1] <majority>D</majority>\n [2] <congress>117</congress>\n [3] <session>1st</session>\n [4] <chamber>U.S. House of Representatives</chamber>\n [5] <rollcall-num>188</rollcall-num>\n [6] <legis-num>H R 391</legis-num>\n [7] <vote-question>On Motion to Suspend the Rules and Pass, as Amended</vote ...\n [8] <vote-type>2/3 YEA-AND-NAY</vote-type>\n [9] <vote-result>Passed</vote-result>\n[10] <action-date>28-Jun-2021</action-date>\n[11] <action-time time-etz=\"19:42\">7:42 PM</action-time>\n[12] <vote-desc>Global Health Security Act</vote-desc>\n[13] <vote-totals>\\n  <totals-by-party-header>\\n    <party-header>Party</part ...\n\n[[2]]\n{xml_nodeset (430)}\n [1] <recorded-vote>\\n  <legislator name-id=\"A000370\" sort-field=\"Adams\" unac ...\n [2] <recorded-vote>\\n  <legislator name-id=\"A000055\" sort-field=\"Aderholt\" u ...\n [3] <recorded-vote>\\n  <legislator name-id=\"A000371\" sort-field=\"Aguilar\" un ...\n [4] <recorded-vote>\\n  <legislator name-id=\"A000372\" sort-field=\"Allen\" unac ...\n [5] <recorded-vote>\\n  <legislator name-id=\"A000376\" sort-field=\"Allred\" una ...\n [6] <recorded-vote>\\n  <legislator name-id=\"A000369\" sort-field=\"Amodei\" una ...\n [7] <recorded-vote>\\n  <legislator name-id=\"A000377\" sort-field=\"Armstrong\"  ...\n [8] <recorded-vote>\\n  <legislator name-id=\"A000375\" sort-field=\"Arrington\"  ...\n [9] <recorded-vote>\\n  <legislator name-id=\"A000148\" sort-field=\"Auchincloss ...\n[10] <recorded-vote>\\n  <legislator name-id=\"A000378\" sort-field=\"Axne\" unacc ...\n[11] <recorded-vote>\\n  <legislator name-id=\"B001291\" sort-field=\"Babin\" unac ...\n[12] <recorded-vote>\\n  <legislator name-id=\"B001298\" sort-field=\"Bacon\" unac ...\n[13] <recorded-vote>\\n  <legislator name-id=\"B001307\" sort-field=\"Baird\" unac ...\n[14] <recorded-vote>\\n  <legislator name-id=\"B001306\" sort-field=\"Balderson\"  ...\n[15] <recorded-vote>\\n  <legislator name-id=\"B001299\" sort-field=\"Banks\" unac ...\n[16] <recorded-vote>\\n  <legislator name-id=\"B001282\" sort-field=\"Barr\" unacc ...\n[17] <recorded-vote>\\n  <legislator name-id=\"B001300\" sort-field=\"Barragan\" u ...\n[18] <recorded-vote>\\n  <legislator name-id=\"B001270\" sort-field=\"Bass\" unacc ...\n[19] <recorded-vote>\\n  <legislator name-id=\"B001281\" sort-field=\"Beatty\" una ...\n[20] <recorded-vote>\\n  <legislator name-id=\"B000668\" sort-field=\"Bentz\" unac ...\n...\n\n\nOne node contains the aggregated vote information, while <vote-data> contains the legislator-level vote data. Let’s try to parse the legislator-level data first.\n\nCode(vote_data = xml_find_all(vote_roll_xml, \"vote-data\"))\n\n{xml_nodeset (1)}\n[1] <vote-data>\\n  <recorded-vote>\\n    <legislator name-id=\"A000370\" sort-fi ...\n\n\nHere is the XML for a single legislator’s vote:\n\nCodexml_child(vote_data)\n\n{xml_node}\n<recorded-vote>\n[1] <legislator name-id=\"A000370\" sort-field=\"Adams\" unaccented-name=\"Adams\"  ...\n[2] <vote>Yea</vote>\n\n\nWith a similar combination of as_list() , flatten_dfr(), and unnest() we can flatten the XML into one row per legislator\n\nCode(vote_roll_flattened = vote_data %>% \n  as_list() %>% \n  flatten_dfr() %>% \n    unnest(everything()))\n\n# A tibble: 430 × 2\n   legislator  vote \n   <chr>       <chr>\n 1 Adams       Yea  \n 2 Aderholt    Nay  \n 3 Aguilar     Yea  \n 4 Allen       Nay  \n 5 Allred      Yea  \n 6 Amodei      Yea  \n 7 Armstrong   Yea  \n 8 Arrington   Nay  \n 9 Auchincloss Yea  \n10 Axne        Yea  \n# … with 420 more rows\n\n\nBut we lose all the attributes! And name-id looked particularly useful. We’ll need to extract the attributes before we flatten the data. Let’s take another look at the legislators structure.\n\nCodevote_legislators = vote_data %>% \n  xml_find_all(\"recorded-vote\")\n\n(legislators_list = as_list(vote_legislators))[1] %>% \n  glimpse()\n\nList of 1\n $ :List of 2\n  ..$ legislator:List of 1\n  .. ..$ : chr \"Adams\"\n  .. ..- attr(*, \"name-id\")= chr \"A000370\"\n  .. ..- attr(*, \"sort-field\")= chr \"Adams\"\n  .. ..- attr(*, \"unaccented-name\")= chr \"Adams\"\n  .. ..- attr(*, \"party\")= chr \"D\"\n  .. ..- attr(*, \"state\")= chr \"NC\"\n  .. ..- attr(*, \"role\")= chr \"legislator\"\n  ..$ vote      :List of 1\n  .. ..$ : chr \"Yea\"\n\n\nThe legislator element has all the attributes, while the vote element only has a value. We want to extract the attributes only for legislator using map() to apply map_at() on each legislator element and extract the attributes from each while retaining the value in vote. It can often feel like you’re getting lost in a list of lists, but with some experimentation you’ll be able to find your way back to the surface.\n\nCode(legislator_vote_df = legislators_list %>% \n    # Modify one level deeper using map_at to target legislator elements\n    map(map_at, \"legislator\", attributes) %>% \n    map_dfr(flatten_dfc))\n\n# A tibble: 430 × 7\n   `name-id` `sort-field` `unaccented-name` party state role       vote \n   <chr>     <chr>        <chr>             <chr> <chr> <chr>      <chr>\n 1 A000370   Adams        Adams             D     NC    legislator Yea  \n 2 A000055   Aderholt     Aderholt          R     AL    legislator Nay  \n 3 A000371   Aguilar      Aguilar           D     CA    legislator Yea  \n 4 A000372   Allen        Allen             R     GA    legislator Nay  \n 5 A000376   Allred       Allred            D     TX    legislator Yea  \n 6 A000369   Amodei       Amodei            R     NV    legislator Yea  \n 7 A000377   Armstrong    Armstrong         R     ND    legislator Yea  \n 8 A000375   Arrington    Arrington         R     TX    legislator Nay  \n 9 A000148   Auchincloss  Auchincloss       D     MA    legislator Yea  \n10 A000378   Axne         Axne              D     IA    legislator Yea  \n# … with 420 more rows\n\n\nNow we have a table of legislator voting data! But what about the <vote-metadata>?\n\nCode(vote_metadata = xml_find_all(vote_roll_xml, \"vote-metadata\")) %>% \n  xml_contents()\n\n{xml_nodeset (13)}\n [1] <majority>D</majority>\n [2] <congress>117</congress>\n [3] <session>1st</session>\n [4] <chamber>U.S. House of Representatives</chamber>\n [5] <rollcall-num>188</rollcall-num>\n [6] <legis-num>H R 391</legis-num>\n [7] <vote-question>On Motion to Suspend the Rules and Pass, as Amended</vote ...\n [8] <vote-type>2/3 YEA-AND-NAY</vote-type>\n [9] <vote-result>Passed</vote-result>\n[10] <action-date>28-Jun-2021</action-date>\n[11] <action-time time-etz=\"19:42\">7:42 PM</action-time>\n[12] <vote-desc>Global Health Security Act</vote-desc>\n[13] <vote-totals>\\n  <totals-by-party-header>\\n    <party-header>Party</part ...\n\n\nEverything other than the <vote-totals> element is singular so we can get that out of the way the same way as before:\n\nCodevote_singular_nodes = xml_singular_nodes(vote_metadata)\n\n(vote_df = as_list(vote_singular_nodes) %>% \n  # as_list() doesn't retain element names so we set names ourselves\n  setNames(xml_name(vote_singular_nodes)) %>% \n  flatten_dfc()) %>% \n  glimpse()\n\nRows: 1\nColumns: 12\n$ majority        <chr> \"D\"\n$ congress        <chr> \"117\"\n$ session         <chr> \"1st\"\n$ chamber         <chr> \"U.S. House of Representatives\"\n$ `rollcall-num`  <chr> \"188\"\n$ `legis-num`     <chr> \"H R 391\"\n$ `vote-question` <chr> \"On Motion to Suspend the Rules and Pass, as Amended\"\n$ `vote-type`     <chr> \"2/3 YEA-AND-NAY\"\n$ `vote-result`   <chr> \"Passed\"\n$ `action-date`   <chr> \"28-Jun-2021\"\n$ `action-time`   <chr> \"7:42 PM\"\n$ `vote-desc`     <chr> \"Global Health Security Act\"\n\n\nThe <vote-totals> are a bit of a unique little element, with 3 different types of nodes.\n\nCode(vote_totals = xml_find_all(vote_metadata, \"vote-totals\")) %>% \n  xml_contents()\n\n{xml_nodeset (5)}\n[1] <totals-by-party-header>\\n  <party-header>Party</party-header>\\n  <yea-he ...\n[2] <totals-by-party>\\n  <party>Republican</party>\\n  <yea-total>90</yea-tota ...\n[3] <totals-by-party>\\n  <party>Democratic</party>\\n  <yea-total>217</yea-tot ...\n[4] <totals-by-party>\\n  <party>Independent</party>\\n  <yea-total>0</yea-tota ...\n[5] <totals-by-vote>\\n  <total-stub>Totals</total-stub>\\n  <yea-total>307</ye ...\n\n\nThis is another opportunity for us to be choosy with our data. The first node is table headers, which we don’t need because the elements are tagged anyway. From these, we really only need the <totals-by-party> nodes as long as the totals of which agree with <totals-by-vote> , which is worth checking.\n\nCode(vote_totals_by_party = xml_find_all(vote_totals, \"totals-by-party\"))\n(totals_by_vote = xml_find_all(vote_totals, \"totals-by-vote\")) %>% \n  xml_contents()\n\n\n\n{xml_nodeset (3)}\n[1] <totals-by-party>\\n  <party>Republican</party>\\n  <yea-total>90</yea-tota ...\n[2] <totals-by-party>\\n  <party>Democratic</party>\\n  <yea-total>217</yea-tot ...\n[3] <totals-by-party>\\n  <party>Independent</party>\\n  <yea-total>0</yea-tota ...\n\n\n{xml_nodeset (5)}\n[1] <total-stub>Totals</total-stub>\n[2] <yea-total>307</yea-total>\n[3] <nay-total>112</nay-total>\n[4] <present-total>0</present-total>\n[5] <not-voting-total>11</not-voting-total>\n\n\n\n\nOnce we have our nodeset (which at last are all singular), we use same listing, mapping, and flattening…or lappening as absolutely no one calls it.\n\nCode(party_vote_totals_df = vote_totals_by_party %>% \n  as_list() %>% \n  map_dfr(flatten_dfc) %>% \n    type_convert())\n\n# A tibble: 3 × 5\n  party       `yea-total` `nay-total` `present-total` `not-voting-total`\n  <chr>             <dbl>       <dbl>           <dbl>              <dbl>\n1 Republican           90         112               0                  9\n2 Democratic          217           0               0                  2\n3 Independent           0           0               0                  0\n\n\nNow that we have all of our vote data wrangled from the thorny grasp of XML, we can put it all together.\n\nCode(vote_roll_df = vote_df %>% \n  mutate(legislator_votes = list(legislator_vote_df),\n         party_votes = list(party_vote_totals_df)) %>% \n    janitor::clean_names()) %>% \n  glimpse()\n\nRows: 1\nColumns: 14\n$ majority         <chr> \"D\"\n$ congress         <chr> \"117\"\n$ session          <chr> \"1st\"\n$ chamber          <chr> \"U.S. House of Representatives\"\n$ rollcall_num     <chr> \"188\"\n$ legis_num        <chr> \"H R 391\"\n$ vote_question    <chr> \"On Motion to Suspend the Rules and Pass, as Amended\"\n$ vote_type        <chr> \"2/3 YEA-AND-NAY\"\n$ vote_result      <chr> \"Passed\"\n$ action_date      <chr> \"28-Jun-2021\"\n$ action_time      <chr> \"7:42 PM\"\n$ vote_desc        <chr> \"Global Health Security Act\"\n$ legislator_votes <list> [<tbl_df[430 x 7]>]\n$ party_votes      <list> [<tbl_df[3 x 5]>]\n\n\nAnd we continue to stack this Russian doll of data from the legislator-level to the vote-level…\n\nCode(recorded_votes_df = recorded_votes_df %>% \n  mutate(vote_roll = list(vote_roll_df))) %>% \n  glimpse()\n\nRows: 1\nColumns: 8\n$ rollNumber     <chr> \"188\"\n$ url            <chr> \"https://clerk.house.gov/evs/2021/roll188.xml\"\n$ fullActionName <chr> \"Final Passage Under Suspension of the Rules Results\"\n$ chamber        <chr> \"House\"\n$ congress       <chr> \"117\"\n$ date           <chr> \"2021-06-28T23:46:02Z\"\n$ sessionNumber  <chr> \"1\"\n$ vote_roll      <list> [<tbl_df[1 x 14]>]\n\n\n…all the way until we’ve gotten back to the bill-level.\n\nCodebill_df$votes = list(recorded_votes_df)\n\nglimpse(bill_df)\n\nRows: 1\nColumns: 12\n$ billNumber                           <chr> \"391\"\n$ createDate                           <chr> \"2021-01-22T08:12:10Z\"\n$ updateDate                           <chr> \"2022-02-09T12:37:52Z\"\n$ originChamber                        <chr> \"House\"\n$ billType                             <chr> \"HR\"\n$ introducedDate                       <chr> \"2021-01-21\"\n$ congress                             <chr> \"117\"\n$ constitutionalAuthorityStatementText <chr> \"<pre>[Congressional Record Volum…\n$ title                                <chr> \"Global Health Security Act of 20…\n$ version                              <chr> \"1.0.0\"\n$ actions                              <list> [<tbl_df[14 x 9]>]\n$ votes                                <list> [<tbl_df[1 x 8]>]"
  }
]