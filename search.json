[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Mark Barrett",
    "section": "",
    "text": "I am an analyst with a passion for behavioural science, public policy, and R. The purpose of this website is to build a data analysis portfolio and write about policy issues that matter to me.\nI am interested in decision-making, governance institutions, and information systems, and particularly where these topics overlap."
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "Mark Barrett",
    "section": "Education",
    "text": "Education\nLoyola Marymount University | Los Angeles, CA\nB.S in Economics & Psychology | Aug. 2012 - May 2016"
  },
  {
    "objectID": "about.html#experience",
    "href": "about.html#experience",
    "title": "Mark Barrett",
    "section": "Experience",
    "text": "Experience\nRAND Corporation\nResearch Assistant | Apr. 2016 - Feb. 2020\nCBRE\nSr. Research Data Analyst | Mar. 2020 - May 2022\nKarl Storz\nSr. Business Analyst | June 2022 - present"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "30 min\n\n\n\n\n\n\nJul 14, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3 min\n\n\n\n\n\n\nOct 3, 2022\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hi, I’m Mark.",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n\n\n\n\n  \n\n\n\n\n\nAnd how behavioural science can help.\n\n\n\n\n\n\nOct 3, 2022\n\n\n3 min\n\n\n\n\n\n\n  \n\n\n\n\n\nUntangling data from complex XML structures using {XML} and {xml2}\n\n\n\n\n\n\nJul 14, 2022\n\n\n30 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/institutional-decisionmaking/index.html",
    "href": "posts/institutional-decisionmaking/index.html",
    "title": "Why institutional decision-making needs improving",
    "section": "",
    "text": "Meanwhile, our information systems have become heavily dependent on social media platforms corporations which explicitly do not have responsibility for content posted on their platforms. That is not to say they should bear this responsibility, because that would likely lead to overly-conservative censorship of content to avoid litigation. But when misinformation is proliferating on platforms, the founder of Facebook is pleading for Congress to step in, and legislators are demonstrating a profound lack of expertise in the technologies at hand, we need to improve the decisions being made in one or both of these institutions.\nInstitutional decision-making is vague so it is important to clarify what is meant by institutions and decision-making. I borrow definitions from the Effective Institutions Project because they do an excellent job balancing comprehensiveness with brevity.\n\nThe definition of an institution is not completely standardized across disciplines or academic fields, but in this context we mean a formally organized group of people, usually delineated by some sort of legal entity (or an interconnected set of such entities) in the jurisdiction(s) in which that group operates.\n\n\n…when we speak of “decision-making,” we are using that term broadly to refer to all of the aspects of the process leading up to an institution’s actions over which that institution has agency.\n\nSo put together, it means we want to understand the processes of a (usually) legal entity for achieving its aims. In the case of governments, these aims are usually to provide a safe, economically viable state for its citizens and residents, while corporations are usually required to deliver as much value to shareholders as possible.\nConsidering what an institution actually intends to do is related to the first of two pathways defined by the Effective Institutions Project for improving institutional decision-making. It is particularly important that powerful institutions, whose decisions can have broad second- and third-order consequences, are driven to improve global outcomes and factor in the scope of their impact beyond the likely more narrow set of interests that determine their actions. Once an institution at least has aims which are consistent with improving global outcomes, the next step is to understand the effectiveness of their process for achieving their aims.\nThis is where behavioural science comes in. The last five decades of behavioural science research has been ground-breaking to say the least. Researchers have identified how errors occur in our decision-making, how different contexts affect our thinking, and what this actually means for criminal justice outcomes, hiring decisions, and many more. For most institutions, the processes in place to achieve their intended outcomes necessarily involve human judgement, intuition, and group decision-making, which likely introduces a variety of errors in judgement.\nIn the face of challenges as complex and structurally interdependent as climate change and AI safety, we need institutions driven by holistic, altruistically-defined aims, and which are designed to effectively achieve those aims. Using research from behavioural science to inoculate and support decision-making from biases and judgement errors could enhance our problem-solving capacity for issues from pandemic response preparedness to political gridlock.\n\n\n\n\n\n\nUnder Construction\n\n\n\n\n\n\nMore to come soon."
  },
  {
    "objectID": "posts/parse-xml/index.html",
    "href": "posts/parse-xml/index.html",
    "title": "Parsing XML with R",
    "section": "",
    "text": "Unlike Excel spreadsheets, CSV files, and other tabular formats, (e)Xtensible Markup Language (XML) is a storage format designed to contain any “arbitrary” structure1 of data. XML’s flexibility is useful for storing information like financial transactions and recipes to webpage content and document formatting2. If you have worked with XML before, you’ll know it can be a bit of a pain to transform into a tabular format typically used in data analysis. The good news is you’re not alone! This article will help you to load XML files with R, extract what you need from them, and store the results in a analysis-friendly data frame."
  },
  {
    "objectID": "posts/parse-xml/index.html#convert-an-xml-nodeset-to-a-data-frame",
    "href": "posts/parse-xml/index.html#convert-an-xml-nodeset-to-a-data-frame",
    "title": "Parsing XML with R",
    "section": "Convert an XML nodeset to a data frame",
    "text": "Convert an XML nodeset to a data frame\nWhen converting XML into a data frame, one of the simplest cases to deal with is a set of nodes which each have a single value. You can think of singular nodes as the contents of a single cell in a data frame. When your data are entirely made up of nodes like this, you can convert XML to a data frame using two functions from XML:\n\nxmlParse() parses an XML file into an R structure9 representing the XML tree\nxmlToDataFrame() extracts data from an XML document directly into a data frame, but with limited flexibility\n\n\n\n\n\n\n\nNote\n\n\n\nIn the example below, we need to use getNodeSet(., [path =] \"//bill\") to select only nodes in <bill>. If we just passed bill_xml_parse, we would get a dataframe with two rows because the top-level nodes are bill and the metadata identifier node <dublinCore>.\n\n\n\nUse {XML} functions to read XML data# First we need to use xmlParse function to create XMLDocument object\nbill_xml_parse = xmlParse(bill_xml)\n\nxmlToDataFrame(getNodeSet(bill_xml_parse, \"//bill\")) %>% \n  glimpse()\n\nOutput of xmlToDataFrame\nRows: 1\nColumns: 28\n$ billNumber                           <chr> \"391\"\n$ createDate                           <chr> \"2021-01-22T08:12:10Z\"\n$ updateDate                           <chr> \"2022-09-07T13:37:22Z\"\n$ originChamber                        <chr> \"House\"\n$ billType                             <chr> \"HR\"\n$ introducedDate                       <chr> \"2021-01-21\"\n$ congress                             <chr> \"117\"\n$ constitutionalAuthorityStatementText <chr> \"<pre>[Congressional Record Volum…\n$ recordedVotes                        <chr> \"188https://clerk.house.gov/evs/2…\n$ committees                           <chr> \"ssfr00Foreign Relations Committe…\n$ committeeReports                     <chr> \"\"\n$ relatedBills                         <chr> \"\"\n$ actions                              <chr> \"2021-07-12ssfr00Foreign Relation…\n$ sponsors                             <chr> \"C001078Rep. Connolly, Gerald E. …\n$ cosponsors                           <chr> \"C000266Rep. Chabot, Steve [R-OH-…\n$ cboCostEstimates                     <chr> \"2021-05-11T15:11:11ZH.R. 391, Gl…\n$ laws                                 <chr> \"\"\n$ notes                                <chr> \"\"\n$ policyArea                           <chr> \"International Affairs\"\n$ subjects                             <chr> \"Advisory bodiesAnimal and plant …\n$ summaries                            <chr> \"002021-01-21Introduced in House2…\n$ title                                <chr> \"Global Health Security Act of 20…\n$ titles                               <chr> \"Display TitleGlobal Health Secur…\n$ amendments                           <chr> \"\"\n$ textVersions                         <chr> \"Referred in Senate2021-07-12T04:…\n$ latestAction                         <chr> \"2021-07-12Received in the Senate…\n$ calendarNumbers                      <chr> \"\"\n$ version                              <chr> \"1.0.0\"\n\n\n\nBecause the congressional data has elements like committees, actions, and sponsors which contain multiple sub-elements, the contents are combined into single columns. When parsing nested XML like this, it might require multiple steps to get the data into a tidy data frame.\nIn this case, the first step is to isolate singular elements like billNumber and billType, and deal with nested elements individually afterwards.\nSingular elements are nodes which meet two criteria:\n\nthe node does not have any child nodes of its own, and\nthe node is not an empty string.\n\nWe can use xml_find_all() to filter an XML document with XPath (XML Path Language). The XPATH expression selects the nodes which match the given path or pattern10 in a similar way as regular expressions. As the function’s help file says, “XPath is like regular expressions for trees”.\nIn the code below the [ expressions within the square brackets ] are called predicates which I use to find nodes which have no children with the XPath count function and nodes which are not empty strings11. This returns an {xml_nodeset} which can be coerced to a list using as_list().\n\nSelect non-empty child-less elements using XPathsingular_nodes = xml_find_all(bill_xml, \n                              # //bill/* selects the child nodes in a bill\n                              \"//bill/*[count(./*) = 0 and not(string-length(.) = 0)]\")\n\n(singular_list = as_list(singular_nodes)) %>% \n  glimpse()\n\nList of 10\n $ :List of 1\n  ..$ : chr \"391\"\n $ :List of 1\n  ..$ : chr \"2021-01-22T08:12:10Z\"\n $ :List of 1\n  ..$ : chr \"2022-09-07T13:37:22Z\"\n $ :List of 1\n  ..$ : chr \"House\"\n $ :List of 1\n  ..$ : chr \"HR\"\n $ :List of 1\n  ..$ : chr \"2021-01-21\"\n $ :List of 1\n  ..$ : chr \"117\"\n $ :List of 1\n  ..$ : chr \"<pre>[Congressional Record Volume 167, Number 17 (Thursday, January 28, 2021)][House]From the Congressional Rec\"| __truncated__\n $ :List of 1\n  ..$ : chr \"Global Health Security Act of 2021\"\n $ :List of 1\n  ..$ : chr \"1.0.0\"\n\n\nNow that we have the data we want in a list, we can flatten each element in the list into a data frame column using purrr’s flatten_dfc(). However, notice the elements in a singular_list are not named. If we flatten this list to a data frame, our columns also won’t have any column names. We can use xml_name() to create a character vector of the nodes’ names in combination with setNames() to create a named list. Just make sure singular_list and singular_nodes are the same length and in the same order.\n\nName the list elementssingular_list_named = setNames(singular_list, \n                                xml_name(singular_nodes))\n\n\nWhen flattened, a named list becomes a data frame with column names in tow.\n\nFlatten singular nodes into data frame(bill_df = flatten_dfc(singular_list_named)) %>% \n  glimpse()\n\nRows: 1\nColumns: 10\n$ billNumber                           <chr> \"391\"\n$ createDate                           <chr> \"2021-01-22T08:12:10Z\"\n$ updateDate                           <chr> \"2022-09-07T13:37:22Z\"\n$ originChamber                        <chr> \"House\"\n$ billType                             <chr> \"HR\"\n$ introducedDate                       <chr> \"2021-01-21\"\n$ congress                             <chr> \"117\"\n$ constitutionalAuthorityStatementText <chr> \"<pre>[Congressional Record Volum…\n$ title                                <chr> \"Global Health Security Act of 20…\n$ version                              <chr> \"1.0.0\"\n\n\nWith the singular nodes transformed, we have the base of our data frame. The next step is to choose a nested element, define its structure in the output, and transform the XML accordingly."
  },
  {
    "objectID": "posts/parse-xml/index.html#transforming-nested-data-into-list-columns",
    "href": "posts/parse-xml/index.html#transforming-nested-data-into-list-columns",
    "title": "Parsing XML with R",
    "section": "Transforming nested data into list columns",
    "text": "Transforming nested data into list columns\nActions are stored in a container node where each <item> represents a congressional action taken for a bill, such as being introduced, sent to a committee, debated on the floor, etc. Just as before, we use as_list() to convert the {xml_nodeset} to a list.\n\nSelect all action elements and convert them to a listactions_xml = xml_find_all(bill_node, \"actions/item\")\n\nactions_list = as_list(actions_xml)\n# Look at first action\nglimpse(actions_list[[1]], width = 50)\n\nStructure of action as list\nList of 6\n $ actionDate  :List of 1\n  ..$ : chr \"2021-07-12\"\n $ committees  :List of 1\n  ..$ item:List of 2\n  .. ..$ systemCode:List of 1\n  .. ..$ name      :List of 1\n $ links       : list()\n $ sourceSystem:List of 2\n  ..$ code:List of 1\n  .. ..$ : chr \"0\"\n  ..$ name:List of 1\n  .. ..$ : chr \"Senate\"\n $ text        :List of 1\n  ..$ : chr \"Received in the Senate and Read twice and referred to the Committee on Foreign Relations.\"\n $ type        :List of 1\n  ..$ : chr \"IntroReferral\"\n\n\n\nFor an individual action, we have the date, a list of committees related to the action, some administrative information, the text and type of action. To deal with this, we can write a function (or set of functions) like the ones below to transform actions from a list to a data frame with their own nested elements.\n\nView helper functions#' Helper function: flatten_dfc_rename\n#' Flatten a list into a data frame and apply a prefix to the column names\n#'\n#' @param list_to_flatten A list to flatten\n#' @param name_prefix A string to apply as a prefix to columns\n#'\n#' @return A data frame of columns that begin with the prefix\nflatten_dfc_rename = function(list_to_flatten, \n                              name_prefix = \"prefix\"){\n  rename_with(\n    .data = flatten_dfc(list_to_flatten), \n    .fn = ~str_c(name_prefix, \"_\", .),\n    # Exclude columns which already start with the prefix\n    .cols = -starts_with(name_prefix)\n  )\n}\n\n#' Function: parse_action\n#' Parse actions from list to data frame\n#' \n#' Separately flatten and rename source system and committee elements,\n#' then flatten and rename remaining elements. \n#' Committee elements are flattened into a nested data frame \n#' because an action can relate to multiple committees.\n#'\n#' @param action An action element in list form\n#'\n#' @return A data frame with a single row containing action information\nparse_action = function(action){\n  action %>% \n    # Flatten + rename sourceSystem elements\n    map_at(\"sourceSystem\", ~flatten_dfc_rename(.x, \"source\")) %>% \n    # Flatten + rename committees\n    map_at(\"committees\", function(committee){\n      # using map_at and map_dfr to create a data frame row for each committee\n      map_dfr(committee, ~flatten_dfc_rename(.x, \"committee\"))\n    }) %>% \n    # Flatten object to data frame\n    flatten_dfc_rename(., \"action\") %>% \n    # Lastly, clean the names\n    janitor::clean_names()\n}\n\n\nUsing the purrr library’s map_dfr(), we apply my parse_action() function to each element of our actions list and combine the results into data frame rows.\n\nParse actions and combine into data frame(actions_df = map_dfr(actions_list, parse_action)) %>% \n  glimpse()\n\nRows: 14\nColumns: 9\n$ action_date                  <chr> \"2021-07-12\", \"2021-06-28\", \"2021-06-28\",…\n$ action_committee_system_code <chr> \"ssfr00\", NA, NA, NA, NA, NA, NA, NA, NA,…\n$ action_committee_name        <chr> \"Foreign Relations Committee\", NA, NA, NA…\n$ action_source_code           <chr> \"0\", \"2\", \"2\", \"9\", \"2\", \"2\", \"2\", \"2\", \"…\n$ action_source_name           <chr> \"Senate\", \"House floor actions\", \"House f…\n$ action_text                  <chr> \"Received in the Senate and Read twice an…\n$ action_type                  <chr> \"IntroReferral\", \"Floor\", \"Floor\", \"Floor…\n$ action_time                  <chr> NA, \"19:46:03\", \"19:46:02\", \"19:46:02\", \"…\n$ action_code                  <chr> NA, \"H38310\", \"H37300\", \"8000\", \"H30000\",…\n\n\nWhen you plan to combine rows into a data frame or unnest() the data in the future, it is useful to be explicit about the expected data types of each column. This can be done using type_convert().\n\nSpecify column types# Specify column data types\nactions_col_types = cols(\n  action_date = col_date(),\n  action_time = col_time(),\n  action_committee_systemCode = col_character(), \n  action_committee_name = col_character(), \n  action_source_code = col_character(),\n  action_source_name = col_character(),\n  action_text = col_character(), \n  action_type = col_character(), \n  action_code = col_character()\n  )\n\n# Convert column types\nactions_df = type_convert(actions_df,\n                          col_types = actions_col_types)\n\n\nBecause we are only adding a single row of data to bill_df we can encase the actions in a list and use dollar assignment. If you were adding multiple rows of data, you would need to make sure that you are adding a column of the same length as bill_df.\n\nAssign actions as list column in our data framebill_df$actions = list(actions_df)"
  },
  {
    "objectID": "posts/parse-xml/index.html#when-they-put-xml-in-your-xml",
    "href": "posts/parse-xml/index.html#when-they-put-xml-in-your-xml",
    "title": "Parsing XML with R",
    "section": "When they put XML in your XML",
    "text": "When they put XML in your XML\nSo we’ve dealt with cases with multiple child elements, but XML allows for all sorts of weird and wonderful storage options. The congressional data includes information about votes taken on a bill, the total vote count, and the votes of individual legislators. However, only the high level information is included in the <recordedVotes> element. the more detailed information on individual legislators’ votes are contained in an XML file referenced by the <url> element as you can see below.12\n\nAssign actions as list column in our data frame# Find recordedVote nodes inside recordedVote container\nbill_recorded_vote_nodes = xml_find_all(\n  bill_node, \n  \"recordedVotes/recordedVote\"\n  )\n\n# Look at the nodeset contents\nxml_contents(bill_recorded_vote_nodes)\n\n{xml_nodeset (7)}\n[1] <rollNumber>188</rollNumber>\n[2] <url>https://clerk.house.gov/evs/2021/roll188.xml</url>\n[3] <fullActionName>Final Passage Under Suspension of the Rules Results</full ...\n[4] <chamber>House</chamber>\n[5] <congress>117</congress>\n[6] <date>2021-06-28T23:46:02Z</date>\n[7] <sessionNumber>1</sessionNumber>\n\n\nBefore we dive one level deeper, we can convert the top-level nodes to a list and flatten it into columns to start building our vote-level data frame.\n\nConvert <recordedVotes> to a list and flatten into data frame# Coerce nodes to list\nrecorded_votes_list = as_list(bill_recorded_vote_nodes)\n\n(recorded_votes_df = map_dfr(recorded_votes_list, flatten_dfc)) %>% \n  glimpse()\n\nRows: 1\nColumns: 7\n$ rollNumber     <chr> \"188\"\n$ url            <chr> \"https://clerk.house.gov/evs/2021/roll188.xml\"\n$ fullActionName <chr> \"Final Passage Under Suspension of the Rules Results\"\n$ chamber        <chr> \"House\"\n$ congress       <chr> \"117\"\n$ date           <chr> \"2021-06-28T23:46:02Z\"\n$ sessionNumber  <chr> \"1\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nWe use flatten_dfc() to flatten each vote element into a data frame as columns and then map_dfr() rolls them all up as rows into a single data frame.\n\n\nNow to get the vote roll XML file we’ll use read_xml() . There are two main nodes - <vote-metadata> and <vote-data>. One node contains the aggregated vote information, while <vote-data> contains the legislator-level vote data. We’ll focus on <vote-data> here.\n\nRead vote roll data and convert to listvote_roll_xml = read_xml(recorded_votes_df$url)\n\n# Find all vote-data elements\nvote_data = xml_find_all(vote_roll_xml, \"vote-data\")\n\n# Find all recorded-vote elements\nvote_legislators = xml_find_all(vote_data, \"recorded-vote\")\n\n# Convert to list and show first element\n(legislators_list = as_list(vote_legislators))[1] %>% \n  glimpse()\n\nList of 1\n $ :List of 2\n  ..$ legislator:List of 1\n  .. ..$ : chr \"Adams\"\n  .. ..- attr(*, \"name-id\")= chr \"A000370\"\n  .. ..- attr(*, \"sort-field\")= chr \"Adams\"\n  .. ..- attr(*, \"unaccented-name\")= chr \"Adams\"\n  .. ..- attr(*, \"party\")= chr \"D\"\n  .. ..- attr(*, \"state\")= chr \"NC\"\n  .. ..- attr(*, \"role\")= chr \"legislator\"\n  ..$ vote      :List of 1\n  .. ..$ : chr \"Yea\"\n\n\nIf we use the same combination of as_list() , map_dfr(), and flatten_dfc() we can flatten the XML into one row per legislator but we lose all the attributes.\n\nConvert list of votes to data frame and LOSE attributes(vote_roll_flattened = as_list(vote_legislators) %>% \n  map_dfr(flatten_dfc))\n\n# A tibble: 430 × 2\n   legislator  vote \n   <chr>       <chr>\n 1 Adams       Yea  \n 2 Aderholt    Nay  \n 3 Aguilar     Yea  \n 4 Allen       Nay  \n 5 Allred      Yea  \n 6 Amodei      Yea  \n 7 Armstrong   Yea  \n 8 Arrington   Nay  \n 9 Auchincloss Yea  \n10 Axne        Yea  \n# … with 420 more rows\n\n\nTo extract the attributes before we flatten the data, we can apply map_at() to each legislator element and extract the attributes from each while retaining the value in vote.13\n\nExtract attributes to list elements(legislator_attr = legislators_list %>% \n    # Modify one level deeper using map_at to target legislator elements\n    map(map_at, \"legislator\", attributes))[[1]] %>% \n  glimpse()\n\nList of 2\n $ legislator:List of 6\n  ..$ name-id        : chr \"A000370\"\n  ..$ sort-field     : chr \"Adams\"\n  ..$ unaccented-name: chr \"Adams\"\n  ..$ party          : chr \"D\"\n  ..$ state          : chr \"NC\"\n  ..$ role           : chr \"legislator\"\n $ vote      :List of 1\n  ..$ : chr \"Yea\"\n\n\n\nConvert list of votes to data frame and KEEP attributes(legislator_vote_df = map_dfr(legislator_attr, flatten_dfc) %>% \n    # Use {janitor} to clean up the column names\n    janitor::clean_names()) %>% \n  glimpse()\n\nRows: 430\nColumns: 7\n$ name_id         <chr> \"A000370\", \"A000055\", \"A000371\", \"A000372\", \"A000376\",…\n$ sort_field      <chr> \"Adams\", \"Aderholt\", \"Aguilar\", \"Allen\", \"Allred\", \"Am…\n$ unaccented_name <chr> \"Adams\", \"Aderholt\", \"Aguilar\", \"Allen\", \"Allred\", \"Am…\n$ party           <chr> \"D\", \"R\", \"D\", \"R\", \"D\", \"R\", \"R\", \"R\", \"D\", \"D\", \"R\",…\n$ state           <chr> \"NC\", \"AL\", \"CA\", \"GA\", \"TX\", \"NV\", \"ND\", \"TX\", \"MA\", …\n$ role            <chr> \"legislator\", \"legislator\", \"legislator\", \"legislator\"…\n$ vote            <chr> \"Yea\", \"Nay\", \"Yea\", \"Nay\", \"Yea\", \"Yea\", \"Yea\", \"Nay\"…\n\n\nIt can often feel like you’re getting lost in a list of lists, but with some experimentation you’ll be able to find your way back to the surface.\nNow we have a table of legislator voting data, and the last thing to take care of is the <vote-metadata>. Everything other than the <vote-totals> element is singular so we can get that out of the way the same way as before:\n\nView <vote-metadata> element(vote_metadata = xml_find_all(vote_roll_xml, \"vote-metadata\")) %>% \n  xml_contents()\n\n{xml_nodeset (13)}\n [1] <majority>D</majority>\n [2] <congress>117</congress>\n [3] <session>1st</session>\n [4] <chamber>U.S. House of Representatives</chamber>\n [5] <rollcall-num>188</rollcall-num>\n [6] <legis-num>H R 391</legis-num>\n [7] <vote-question>On Motion to Suspend the Rules and Pass, as Amended</vote ...\n [8] <vote-type>2/3 YEA-AND-NAY</vote-type>\n [9] <vote-result>Passed</vote-result>\n[10] <action-date>28-Jun-2021</action-date>\n[11] <action-time time-etz=\"19:42\">7:42 PM</action-time>\n[12] <vote-desc>Global Health Security Act</vote-desc>\n[13] <vote-totals>\\n  <totals-by-party-header>\\n    <party-header>Party</part ...\n\n\nBecause we have the individual votes, we don’t need to keep the <vote-totals> element, but it is useful to note because it could serve as a check for data consistency in the future. Instead, we’ll just keep the singular nodes in <vote-metadata>\n\nConvert singular vote nodes to data framevote_singular_nodes = xml_singular_nodes(vote_metadata)\n\n(vote_df = as_list(vote_singular_nodes) %>% \n  # as_list() doesn't retain element names so we set names ourselves\n  setNames(xml_name(vote_singular_nodes)) %>% \n  flatten_dfc() %>% \n    janitor::clean_names()) %>% \n  glimpse()\n\nRows: 1\nColumns: 12\n$ majority      <chr> \"D\"\n$ congress      <chr> \"117\"\n$ session       <chr> \"1st\"\n$ chamber       <chr> \"U.S. House of Representatives\"\n$ rollcall_num  <chr> \"188\"\n$ legis_num     <chr> \"H R 391\"\n$ vote_question <chr> \"On Motion to Suspend the Rules and Pass, as Amended\"\n$ vote_type     <chr> \"2/3 YEA-AND-NAY\"\n$ vote_result   <chr> \"Passed\"\n$ action_date   <chr> \"28-Jun-2021\"\n$ action_time   <chr> \"7:42 PM\"\n$ vote_desc     <chr> \"Global Health Security Act\"\n\n\nOnce we have our nodeset (which at last are all singular), we use the same listing, mapping, and flattening…or lappening as absolutely no one calls it.\nNow we can put all the pieces together and nest each element in its parent element until we’ve gotten back to the bill-level i.e. the vote roll data frame goes in the votes data frame, which goes in the bill data frame.\n\nNest each element in their parent data frame# Nest legislator votes in the vote roll data frame\nvote_roll_df = vote_df %>% \n  mutate(legislator_votes = list(legislator_vote_df)) %>% \n    janitor::clean_names()\n\n# Nest vote rolls in the votes data frame\n(recorded_votes_df = recorded_votes_df %>% \n  mutate(vote = list(vote_roll_df))) %>% \n  glimpse()\n\nRows: 1\nColumns: 8\n$ rollNumber     <chr> \"188\"\n$ url            <chr> \"https://clerk.house.gov/evs/2021/roll188.xml\"\n$ fullActionName <chr> \"Final Passage Under Suspension of the Rules Results\"\n$ chamber        <chr> \"House\"\n$ congress       <chr> \"117\"\n$ date           <chr> \"2021-06-28T23:46:02Z\"\n$ sessionNumber  <chr> \"1\"\n$ vote           <list> [<tbl_df[1 x 13]>]\n\nNest each element in their parent data frame# Nest votes in the bill data frame\nbill_df$votes = list(recorded_votes_df)\n\n\nNow we have the bill-level characteristics with action and vote information nested in list columns. We can keep the data at the bill level or unnest() the elements we want to use.\n\n\nBill\nActions\nVotes (Vote-level)\nVotes (Legislator-level)\n\n\n\n\nCodeglimpse(bill_df)\n\nRows: 1\nColumns: 12\n$ billNumber                           <chr> \"391\"\n$ createDate                           <chr> \"2021-01-22T08:12:10Z\"\n$ updateDate                           <chr> \"2022-09-07T13:37:22Z\"\n$ originChamber                        <chr> \"House\"\n$ billType                             <chr> \"HR\"\n$ introducedDate                       <chr> \"2021-01-21\"\n$ congress                             <chr> \"117\"\n$ constitutionalAuthorityStatementText <chr> \"<pre>[Congressional Record Volum…\n$ title                                <chr> \"Global Health Security Act of 20…\n$ version                              <chr> \"1.0.0\"\n$ actions                              <list> [<tbl_df[14 x 9]>]\n$ votes                                <list> [<tbl_df[1 x 8]>]\n\n\n\n\n\nCodeselect(bill_df, billType, billNumber, actions) %>% \n  unnest(actions) %>% \n  glimpse()\n\nRows: 14\nColumns: 11\n$ billType                     <chr> \"HR\", \"HR\", \"HR\", \"HR\", \"HR\", \"HR\", \"HR\",…\n$ billNumber                   <chr> \"391\", \"391\", \"391\", \"391\", \"391\", \"391\",…\n$ action_date                  <date> 2021-07-12, 2021-06-28, 2021-06-28, 2021…\n$ action_committee_system_code <chr> \"ssfr00\", NA, NA, NA, NA, NA, NA, NA, NA,…\n$ action_committee_name        <chr> \"Foreign Relations Committee\", NA, NA, NA…\n$ action_source_code           <chr> \"0\", \"2\", \"2\", \"9\", \"2\", \"2\", \"2\", \"2\", \"…\n$ action_source_name           <chr> \"Senate\", \"House floor actions\", \"House f…\n$ action_text                  <chr> \"Received in the Senate and Read twice an…\n$ action_type                  <chr> \"IntroReferral\", \"Floor\", \"Floor\", \"Floor…\n$ action_time                  <time>       NA, 19:46:03, 19:46:02, 19:46:02, …\n$ action_code                  <chr> NA, \"H38310\", \"H37300\", \"8000\", \"H30000\",…\n\n\n\n\n\nCode# Select bill ID and votes\nselect(bill_df, billType, billNumber, votes) %>% \n  unnest(votes) %>% \n  # Unnest further vote info and add prefix to cols\n  unnest(vote, names_sep = \"_\") %>% \n  glimpse()\n\nRows: 1\nColumns: 22\n$ billType              <chr> \"HR\"\n$ billNumber            <chr> \"391\"\n$ rollNumber            <chr> \"188\"\n$ url                   <chr> \"https://clerk.house.gov/evs/2021/roll188.xml\"\n$ fullActionName        <chr> \"Final Passage Under Suspension of the Rules Res…\n$ chamber               <chr> \"House\"\n$ congress              <chr> \"117\"\n$ date                  <chr> \"2021-06-28T23:46:02Z\"\n$ sessionNumber         <chr> \"1\"\n$ vote_majority         <chr> \"D\"\n$ vote_congress         <chr> \"117\"\n$ vote_session          <chr> \"1st\"\n$ vote_chamber          <chr> \"U.S. House of Representatives\"\n$ vote_rollcall_num     <chr> \"188\"\n$ vote_legis_num        <chr> \"H R 391\"\n$ vote_vote_question    <chr> \"On Motion to Suspend the Rules and Pass, as Ame…\n$ vote_vote_type        <chr> \"2/3 YEA-AND-NAY\"\n$ vote_vote_result      <chr> \"Passed\"\n$ vote_action_date      <chr> \"28-Jun-2021\"\n$ vote_action_time      <chr> \"7:42 PM\"\n$ vote_vote_desc        <chr> \"Global Health Security Act\"\n$ vote_legislator_votes <list> [<tbl_df[430 x 7]>]\n\n\n\n\n\nCode# Select bill ID and votes\nselect(bill_df, billType, billNumber, votes) %>% \n  unnest(votes) %>% \n  # Select bill ID, roll number, and vote list col\n  select(billType:rollNumber, vote) %>% \n  unnest(vote) %>% \n  # Select bill ID, roll number, and legislators list col\n  select(billType:rollNumber, legislator_votes) %>% \n  unnest(legislator_votes) %>% \n  glimpse()\n\nRows: 430\nColumns: 10\n$ billType        <chr> \"HR\", \"HR\", \"HR\", \"HR\", \"HR\", \"HR\", \"HR\", \"HR\", \"HR\", …\n$ billNumber      <chr> \"391\", \"391\", \"391\", \"391\", \"391\", \"391\", \"391\", \"391\"…\n$ rollNumber      <chr> \"188\", \"188\", \"188\", \"188\", \"188\", \"188\", \"188\", \"188\"…\n$ name_id         <chr> \"A000370\", \"A000055\", \"A000371\", \"A000372\", \"A000376\",…\n$ sort_field      <chr> \"Adams\", \"Aderholt\", \"Aguilar\", \"Allen\", \"Allred\", \"Am…\n$ unaccented_name <chr> \"Adams\", \"Aderholt\", \"Aguilar\", \"Allen\", \"Allred\", \"Am…\n$ party           <chr> \"D\", \"R\", \"D\", \"R\", \"D\", \"R\", \"R\", \"R\", \"D\", \"D\", \"R\",…\n$ state           <chr> \"NC\", \"AL\", \"CA\", \"GA\", \"TX\", \"NV\", \"ND\", \"TX\", \"MA\", …\n$ role            <chr> \"legislator\", \"legislator\", \"legislator\", \"legislator\"…\n$ vote            <chr> \"Yea\", \"Nay\", \"Yea\", \"Nay\", \"Yea\", \"Yea\", \"Yea\", \"Nay\"…\n\n\n\n\n\nI’ll stop there for brevity’s sake, but you can find the code for extracting the full XML file here14. Please reach out with any feedback, leave a comment below, or share this with someone who’s struggling with XML. There may even be a reward for anyone who finds mistakes in my code 🤷."
  }
]