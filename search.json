[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Mark Barrett",
    "section": "",
    "text": "I am an analyst with a passion for behavioural science, R, and public policy. This website is for building a data analytics and visualization portfolio, and writing about policy and my research process. My interests include decision-making, governance institutions, and information systems, and particularly areas where these topics coincide."
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "Mark Barrett",
    "section": "Education",
    "text": "Education\nLoyola Marymount University | Los Angeles, CA\nB.S in Economics & Psychology | Aug. 2012 - May 2016"
  },
  {
    "objectID": "about.html#experience",
    "href": "about.html#experience",
    "title": "Mark Barrett",
    "section": "Experience",
    "text": "Experience\nRAND Corporation | Research Assistant | Apr. 2016 - Feb. 2020\nCBRE | Sr. Research Data Analyst | Mar. 2020 - May 2022\nKarl Storz | Sr. Business Analyst | June 2022 - present"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "27 min\n\n\n\n\n\n\nJul 14, 2022\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hi, I’m Mark.",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n\n\n\n\n  \n\n\n\n\n\nUntangling congressional legislative data\n\n\n\n\n\n\nJul 14, 2022\n\n\n27 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/parse-xml/parse-xml.html#singular-elements",
    "href": "posts/parse-xml/parse-xml.html#singular-elements",
    "title": "Parsing XML with R",
    "section": "Singular elements",
    "text": "Singular elements\nYou can think of singular elements as the contents of a single cell in a data frame. In the bookstore example, you could arrange each book as a row and each child node as a column.\n\nCodebookstore_xml_text = '<bookstore>\n  <book category=\"children\">\n    <title>Harry Potter</title>\n    <author>J K. Rowling</author>\n    <year>2005</year>\n    <price>29.99</price>\n  </book>\n  <book category=\"web\">\n    <title>Learning XML</title>\n    <author>Erik T. Ray</author>\n    <year>2003</year>\n    <price>39.95</price>\n  </book>\n</bookstore>'\n\nbookstore_xml_parsed = xmlParse(bookstore_xml_text)\n\n(bookstore_xml_df = xmlToDataFrame(bookstore_xml_parsed))\n\n         title       author year price\n1 Harry Potter J K. Rowling 2005 29.99\n2 Learning XML  Erik T. Ray 2003 39.95\n\n\nIn cases where your data are entirely singular nodes, you can convert XML to a dataframe using two functions from XML8: xmlParse() and xmlToDataFrame(). Because the congressional data has singular and nested element structures, the nested data in fields like committees, actions, and sponsors are combined into single columns. If your data is not all singular nodes like this, you’ll need to do a little bit more work to get the data into a tidy data frame.\n\nCode# First you need to use the xmlParse function\nbill_xml_parse = xmlParse(bill_xml)\n\nxmlToDataFrame(getNodeSet(bill_xml_parse, \"//bill\")) %>% \n  glimpse()\n\nRows: 1\nColumns: 28\n$ billNumber                           <chr> \"391\"\n$ createDate                           <chr> \"2021-01-22T08:12:10Z\"\n$ updateDate                           <chr> \"2022-02-09T12:37:52Z\"\n$ originChamber                        <chr> \"House\"\n$ billType                             <chr> \"HR\"\n$ introducedDate                       <chr> \"2021-01-21\"\n$ congress                             <chr> \"117\"\n$ constitutionalAuthorityStatementText <chr> \"<pre>[Congressional Record Volum…\n$ recordedVotes                        <chr> \"188https://clerk.house.gov/evs/2…\n$ committees                           <chr> \"ssfr00Foreign Relations Committe…\n$ committeeReports                     <chr> \"\"\n$ relatedBills                         <chr> \"\"\n$ actions                              <chr> \"2021-07-12ssfr00Foreign Relation…\n$ sponsors                             <chr> \"C001078Rep. Connolly, Gerald E. …\n$ cosponsors                           <chr> \"C000266Rep. Chabot, Steve [R-OH-…\n$ cboCostEstimates                     <chr> \"2021-05-11T15:11:11ZH.R. 391, Gl…\n$ laws                                 <chr> \"\"\n$ notes                                <chr> \"\"\n$ policyArea                           <chr> \"International Affairs\"\n$ subjects                             <chr> \"Advisory bodiesAnimal and plant …\n$ summaries                            <chr> \"002021-01-21Introduced in House2…\n$ title                                <chr> \"Global Health Security Act of 20…\n$ titles                               <chr> \"Display TitleGlobal Health Secur…\n$ amendments                           <chr> \"\"\n$ textVersions                         <chr> \"Referred in Senate2021-07-12T04:…\n$ latestAction                         <chr> \"2021-07-12Received in the Senate…\n$ calendarNumbers                      <chr> \"\"\n$ version                              <chr> \"1.0.0\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn this example, we actually need to use getNodeSet(., [path =] \"//bill\") to select only nodes in <bill>. If we just passed bill_xml_parse, we would get a dataframe with two rows because the top-level nodes are bill and the metadata identifier node <dublinCore>.\n\n\nTo start building our congressional bill dataset, we need to isolate singular elements like billNumber and billType by selecting nodes which meet two criteria: 1) the node does not have any child nodes of its own, and 2) the node is not an empty string. I use to extract nodes based on an XPath (XML Path Language) string. It returns an {xml_nodeset} which is then coerced to a list using as_list().\nAs the help file for xml_find_all() says, “XPath is like regular expressions for trees”. The expression selects the nodes which match the given path or pattern9. In the code below //bill/* selects the child nodes in a bill. The expressions [ within the square brackets ] are called predicates which I use to find nodes which have no children with the XPath count function and nodes which are not empty strings10.\n\nCodesingular_nodes = xml_find_all(\n  bill_xml, \n  \"//bill/*[count(./*) = 0 and not(string-length(.) = 0)]\"\n  )\n\n(singular_list = as_list(singular_nodes)) %>% \n  glimpse()\n\nList of 10\n $ :List of 1\n  ..$ : chr \"391\"\n $ :List of 1\n  ..$ : chr \"2021-01-22T08:12:10Z\"\n $ :List of 1\n  ..$ : chr \"2022-02-09T12:37:52Z\"\n $ :List of 1\n  ..$ : chr \"House\"\n $ :List of 1\n  ..$ : chr \"HR\"\n $ :List of 1\n  ..$ : chr \"2021-01-21\"\n $ :List of 1\n  ..$ : chr \"117\"\n $ :List of 1\n  ..$ : chr \"<pre>[Congressional Record Volume 167, Number 17 (Thursday, January 28, 2021)][House]From the Congressional Rec\"| __truncated__\n $ :List of 1\n  ..$ : chr \"Global Health Security Act of 2021\"\n $ :List of 1\n  ..$ : chr \"1.0.0\"\n\n\nNote that we didn’t retain the element names so we need to assign them ourselves. When your data is in a named list, you can flatten each element in the list into a data frame column using purrr’s flatten_dfc() .\n\nCodesingular_list_named = setNames(singular_list, \n                                xml_name(singular_nodes))\n\n(bill_df = flatten_dfc(singular_list_named)) %>% \n  glimpse()\n\nRows: 1\nColumns: 10\n$ billNumber                           <chr> \"391\"\n$ createDate                           <chr> \"2021-01-22T08:12:10Z\"\n$ updateDate                           <chr> \"2022-02-09T12:37:52Z\"\n$ originChamber                        <chr> \"House\"\n$ billType                             <chr> \"HR\"\n$ introducedDate                       <chr> \"2021-01-21\"\n$ congress                             <chr> \"117\"\n$ constitutionalAuthorityStatementText <chr> \"<pre>[Congressional Record Volum…\n$ title                                <chr> \"Global Health Security Act of 20…\n$ version                              <chr> \"1.0.0\""
  },
  {
    "objectID": "posts/parse-xml/parse-xml.html#nested-elements",
    "href": "posts/parse-xml/parse-xml.html#nested-elements",
    "title": "Parsing XML with R",
    "section": "Nested elements",
    "text": "Nested elements\nImagine that instead of looking at the data of a single bookstore, you’re looking at the data of all of the bookstores for a big bookstore chain and you want a dataset of bookstores, but also want to include their individual books. This might look something like:\n<bookstores>  \n  ...\n  <bookstore>\n    <id>B1</id>\n    <books>\n      <book category=\"children\">\n        <title>Harry Potter</title>\n        <author>J K. Rowling</author>\n        <year>2005</year>\n        <price>29.99</price>\n      </book>\n      <book category=\"web\">\n        <title>Learning XML</title>\n        <author>Erik T. Ray</author>\n        <year>2003</year>\n        <price>39.95</price>\n      </book>\n    </books>\n  </bookstore>\n  <bookstore>\n    <id>B2</id>\n    ...\n  </bookstore>\n  ...\n</bookstores>\nIn this case, we could store the books as a nested data frame for each bookstore. This is similar to how the congressional data stores actions and votes. The nest()/unnest() functionality of tidyr allows us to change the level of observation as needed.\nTo create each data frame, we isolate the nodes using XPath, and use the same steps as before to convert the XML to a list and then nest them in a list column.\nMultiple children with sub-elements\nActions are stored in a container node where each <item> represents a congressional action taken for a bill, such as being introduced, sent to a committee, debated on the floor, etc. Just as before, we use as_list() to convert the {xml_nodeset} to a list.\n\nCodeactions_xml = xml_find_all(bill_node, \"actions/item\")\n\nactions_list = as_list(actions_xml)\n\n# Look at first action\nglimpse(actions_list[[1]], width = 60)\n\nList of 6\n $ actionDate  :List of 1\n  ..$ : chr \"2021-07-12\"\n $ committees  :List of 1\n  ..$ item:List of 2\n  .. ..$ systemCode:List of 1\n  .. ..$ name      :List of 1\n $ links       : list()\n $ sourceSystem:List of 2\n  ..$ code:List of 1\n  .. ..$ : chr \"0\"\n  ..$ name:List of 1\n  .. ..$ : chr \"Senate\"\n $ text        :List of 1\n  ..$ : chr \"Received in the Senate and Read twice and referred to the Committee on Foreign Relations.\"\n $ type        :List of 1\n  ..$ : chr \"IntroReferral\"\n\n\nFor an individual action, we have the date, a list of committees related to the action, some administrative information, the text and type of action. To deal with this, we can write a function (or set of functions) like the ones below to transform actions from a list to a data frame with their own nested elements.\n\nView Functions# Helper function: flatten_dfc_rename\n# flatten a list to data frame and \n# rename the columns with a given prefix\nflatten_dfc_rename = function(list_to_flatten, \n                          name_prefix = \"prefix\"){\n  rename_with(\n    .data = flatten_dfc(list_to_flatten), \n    .fn = ~str_c(name_prefix, \"_\", .),\n    # Exclude columns which already start with the prefix\n    .cols = -starts_with(name_prefix)\n    )\n}\n\n# Function: parse_action\n# Parse actions from list to data frame\nparse_action = function(action){\n  action %>% \n    # Flatten + rename sourceSystem elements\n    map_at(\"sourceSystem\", ~flatten_dfc_rename(.x, \"source\")) %>% \n    # Flatten + rename committees\n    map_at(\"committees\", function(committee){\n      # using map_at and map_dfr to create a data frame row for each committee\n      map_dfr(committee, ~flatten_dfc_rename(.x, \"committee\"))\n    }) %>% \n    # Flatten object to data frame\n    flatten_dfc_rename(., \"action\") %>% \n    # Lastly, clean the names\n    janitor::clean_names()\n}\n\n\nUsing the purrr library’s map_dfr(), we apply this function to each action and combine the results into data frame rows. Here’s the output of this process:\n\nCode# Parse the first action\n(actions_df = map_dfr(actions_list, parse_action)) %>% \n  glimpse()\n\nRows: 14\nColumns: 9\n$ action_date                  <chr> \"2021-07-12\", \"2021-06-28\", \"2021-06-28\",…\n$ action_committee_system_code <chr> \"ssfr00\", NA, NA, NA, NA, NA, NA, NA, NA,…\n$ action_committee_name        <chr> \"Foreign Relations Committee\", NA, NA, NA…\n$ action_source_code           <chr> \"0\", \"2\", \"2\", \"9\", \"2\", \"2\", \"2\", \"2\", \"…\n$ action_source_name           <chr> \"Senate\", \"House floor actions\", \"House f…\n$ action_text                  <chr> \"Received in the Senate and Read twice an…\n$ action_type                  <chr> \"IntroReferral\", \"Floor\", \"Floor\", \"Floor…\n$ action_time                  <chr> NA, \"19:46:03\", \"19:46:02\", \"19:46:02\", \"…\n$ action_code                  <chr> NA, \"H38310\", \"H37300\", \"8000\", \"H30000\",…\n\n\nWhen you plan to combine rows into a data frame or unnest() the data in the future, it is useful to be explicit about the expected data types of each column. This can be done using type_convert(). Because we are only adding a single row of data to bill_df we can encase the actions in a list and use dollar assignment. If you were adding multiple rows of data, you would need to make sure that you are adding a column of the same length as bill_df.\n\nCodeactions_df = type_convert(actions_df,\n                          col_types = cols(\n                            action_date = col_date(), \n                            action_time = col_time(),\n                            action_committee_systemCode = col_character(), \n                            action_committee_name = col_character(), \n                            action_source_code = col_character(),\n                            action_source_name = col_character(),\n                            action_text = col_character(), \n                            action_type = col_character(), \n                            action_code = col_character()\n                            )\n                          )\n\nbill_df$actions = list(actions_df)\n\n\nNested XML\nSo we’ve dealt with cases with multiple child elements, but you can also have links to XML files within those child elements as you can see in the <url> element below.11\n\nCode(bill_recorded_vote_nodes = xml_find_all(bill_node, \"recordedVotes/recordedVote\"))\n\n{xml_nodeset (1)}\n[1] <recordedVote>\\n  <rollNumber>188</rollNumber>\\n  <url>https://clerk.hous ...\n\n\nBefore we dive one level deeper, to start building our vote-level data frame, we can convert the top-level nodes to a list and flatten it into columns.\n\n\n\n\n\n\nNote\n\n\n\nWe use map_dfr() with votes_list because there could be multiple vote objects.\n\n\n\nCode# Coerce nodes to list\nrecorded_votes_list = as_list(bill_recorded_vote_nodes)\n\n(recorded_votes_df = map_dfr(recorded_votes_list, flatten_dfc)) %>% \n  glimpse()\n\nRows: 1\nColumns: 7\n$ rollNumber     <chr> \"188\"\n$ url            <chr> \"https://clerk.house.gov/evs/2021/roll188.xml\"\n$ fullActionName <chr> \"Final Passage Under Suspension of the Rules Results\"\n$ chamber        <chr> \"House\"\n$ congress       <chr> \"117\"\n$ date           <chr> \"2021-06-28T23:46:02Z\"\n$ sessionNumber  <chr> \"1\"\n\n\nNow we want to get the vote roll XML file, so we’ll need to use read_xml() . There are two main nodes - <vote-metadata> and <vote-data>. One node contains the aggregated vote information, while <vote-data> contains the legislator-level vote data. Let’s parse the legislator-level data first. Here is the XML for a single legislator’s vote:\n\nCodevote_roll_xml = read_xml(recorded_votes_df$url)\n\nvote_data = xml_find_all(vote_roll_xml, \"vote-data\")\n\nvote_legislators = vote_data %>% \n  xml_find_all(\"recorded-vote\")\n\n(legislators_list = as_list(vote_legislators))[1] %>% \n  glimpse()\n\nList of 1\n $ :List of 2\n  ..$ legislator:List of 1\n  .. ..$ : chr \"Adams\"\n  .. ..- attr(*, \"name-id\")= chr \"A000370\"\n  .. ..- attr(*, \"sort-field\")= chr \"Adams\"\n  .. ..- attr(*, \"unaccented-name\")= chr \"Adams\"\n  .. ..- attr(*, \"party\")= chr \"D\"\n  .. ..- attr(*, \"state\")= chr \"NC\"\n  .. ..- attr(*, \"role\")= chr \"legislator\"\n  ..$ vote      :List of 1\n  .. ..$ : chr \"Yea\"\n\n\nWith a similar combination of as_list() , flatten_dfr(), and unnest() we can flatten the XML into one row per legislator but we lose all the attributes.\n\nCode(vote_roll_flattened = vote_data %>% \n  as_list() %>% \n  flatten_dfr() %>% \n    unnest(everything()))\n\n# A tibble: 430 × 2\n   legislator  vote \n   <chr>       <chr>\n 1 Adams       Yea  \n 2 Aderholt    Nay  \n 3 Aguilar     Yea  \n 4 Allen       Nay  \n 5 Allred      Yea  \n 6 Amodei      Yea  \n 7 Armstrong   Yea  \n 8 Arrington   Nay  \n 9 Auchincloss Yea  \n10 Axne        Yea  \n# … with 420 more rows\n\n\nInstead we’ll need to extract the attributes before we flatten the data. We want to extract the attributes only for legislator using map() to apply map_at() on each legislator element and extract the attributes from each while retaining the value in vote. It can often feel like you’re getting lost in a list of lists, but with some experimentation you’ll be able to find your way back to the surface.\n\nCode(legislator_vote_df = legislators_list %>% \n    # Modify one level deeper using map_at to target legislator elements\n    map(map_at, \"legislator\", attributes) %>% \n    map_dfr(flatten_dfc))\n\n# A tibble: 430 × 7\n   `name-id` `sort-field` `unaccented-name` party state role       vote \n   <chr>     <chr>        <chr>             <chr> <chr> <chr>      <chr>\n 1 A000370   Adams        Adams             D     NC    legislator Yea  \n 2 A000055   Aderholt     Aderholt          R     AL    legislator Nay  \n 3 A000371   Aguilar      Aguilar           D     CA    legislator Yea  \n 4 A000372   Allen        Allen             R     GA    legislator Nay  \n 5 A000376   Allred       Allred            D     TX    legislator Yea  \n 6 A000369   Amodei       Amodei            R     NV    legislator Yea  \n 7 A000377   Armstrong    Armstrong         R     ND    legislator Yea  \n 8 A000375   Arrington    Arrington         R     TX    legislator Nay  \n 9 A000148   Auchincloss  Auchincloss       D     MA    legislator Yea  \n10 A000378   Axne         Axne              D     IA    legislator Yea  \n# … with 420 more rows\n\n\nNow we have a table of legislator voting data! But what about the <vote-metadata>? Everything other than the <vote-totals> element is singular so we can get that out of the way the same way as before:\n\nCodevote_metadata = xml_find_all(vote_roll_xml, \"vote-metadata\")\n\nvote_singular_nodes = xml_singular_nodes(vote_metadata)\n\n(vote_df = as_list(vote_singular_nodes) %>% \n  # as_list() doesn't retain element names so we set names ourselves\n  setNames(xml_name(vote_singular_nodes)) %>% \n  flatten_dfc()) %>% \n  glimpse()\n\nRows: 1\nColumns: 12\n$ majority        <chr> \"D\"\n$ congress        <chr> \"117\"\n$ session         <chr> \"1st\"\n$ chamber         <chr> \"U.S. House of Representatives\"\n$ `rollcall-num`  <chr> \"188\"\n$ `legis-num`     <chr> \"H R 391\"\n$ `vote-question` <chr> \"On Motion to Suspend the Rules and Pass, as Amended\"\n$ `vote-type`     <chr> \"2/3 YEA-AND-NAY\"\n$ `vote-result`   <chr> \"Passed\"\n$ `action-date`   <chr> \"28-Jun-2021\"\n$ `action-time`   <chr> \"7:42 PM\"\n$ `vote-desc`     <chr> \"Global Health Security Act\"\n\n\nThe <vote-totals> are a bit of a unique little element, with 3 different types of nodes. This is another opportunity for us to be choosy with our data. The first node is table headers, which we don’t need because the elements are tagged anyway. From these, we really only need the <totals-by-party> nodes as long as the totals of which agree with <totals-by-vote> , which is worth checking.\n\nCode(vote_totals = xml_find_all(vote_metadata, \"vote-totals\")) %>% \n  xml_contents()\nvote_totals_by_party = xml_find_all(vote_totals, \"totals-by-party\")\n\nparty_vote_totals_df = as_list(vote_totals_by_party) %>% \n  map_dfr(flatten_dfc) %>% \n    type_convert()\n\n\n── Column specification ────────────────────────────────────────────────────────\ncols(\n  party = col_character(),\n  `yea-total` = col_double(),\n  `nay-total` = col_double(),\n  `present-total` = col_double(),\n  `not-voting-total` = col_double()\n)\n\nCode(totals_by_vote = xml_find_all(vote_totals, \"totals-by-vote\")) %>% \n  xml_contents()\n\n\n\n{xml_nodeset (5)}\n[1] <totals-by-party-header>\\n  <party-header>Party</party-header>\\n  <yea-he ...\n[2] <totals-by-party>\\n  <party>Republican</party>\\n  <yea-total>90</yea-tota ...\n[3] <totals-by-party>\\n  <party>Democratic</party>\\n  <yea-total>217</yea-tot ...\n[4] <totals-by-party>\\n  <party>Independent</party>\\n  <yea-total>0</yea-tota ...\n[5] <totals-by-vote>\\n  <total-stub>Totals</total-stub>\\n  <yea-total>307</ye ...\n\n\n{xml_nodeset (5)}\n[1] <total-stub>Totals</total-stub>\n[2] <yea-total>307</yea-total>\n[3] <nay-total>112</nay-total>\n[4] <present-total>0</present-total>\n[5] <not-voting-total>11</not-voting-total>\n\n\n\n\nOnce we have our nodeset (which at last are all singular), we use same listing, mapping, and flattening…or lappening as absolutely no one calls it.\nNow that we have all of our vote data wrangled from the thorny grasp of XML, we can put it all together.\n\nCodevote_roll_df = vote_df %>% \n  mutate(legislator_votes = list(legislator_vote_df),\n         party_votes = list(party_vote_totals_df)) %>% \n    janitor::clean_names()\n\n(recorded_votes_df = recorded_votes_df %>% \n  mutate(vote_roll = list(vote_roll_df))) %>% \n  glimpse()\n\nRows: 1\nColumns: 8\n$ rollNumber     <chr> \"188\"\n$ url            <chr> \"https://clerk.house.gov/evs/2021/roll188.xml\"\n$ fullActionName <chr> \"Final Passage Under Suspension of the Rules Results\"\n$ chamber        <chr> \"House\"\n$ congress       <chr> \"117\"\n$ date           <chr> \"2021-06-28T23:46:02Z\"\n$ sessionNumber  <chr> \"1\"\n$ vote_roll      <list> [<tbl_df[1 x 14]>]\n\nCodebill_df$votes = list(recorded_votes_df)\n\n\n…all the way until we’ve gotten back to the bill-level. Now we have the bill-level characteristics with action and vote information nested in list columns. If we want to analyze the actions data, we simply have to unnest() it.\n\nCodeunnest(bill_df, actions) %>% \n  glimpse()\n\nRows: 14\nColumns: 20\n$ billNumber                           <chr> \"391\", \"391\", \"391\", \"391\", \"391\"…\n$ createDate                           <chr> \"2021-01-22T08:12:10Z\", \"2021-01-…\n$ updateDate                           <chr> \"2022-02-09T12:37:52Z\", \"2022-02-…\n$ originChamber                        <chr> \"House\", \"House\", \"House\", \"House…\n$ billType                             <chr> \"HR\", \"HR\", \"HR\", \"HR\", \"HR\", \"HR…\n$ introducedDate                       <chr> \"2021-01-21\", \"2021-01-21\", \"2021…\n$ congress                             <chr> \"117\", \"117\", \"117\", \"117\", \"117\"…\n$ constitutionalAuthorityStatementText <chr> \"<pre>[Congressional Record Volum…\n$ title                                <chr> \"Global Health Security Act of 20…\n$ version                              <chr> \"1.0.0\", \"1.0.0\", \"1.0.0\", \"1.0.0…\n$ action_date                          <date> 2021-07-12, 2021-06-28, 2021-06-…\n$ action_committee_system_code         <chr> \"ssfr00\", NA, NA, NA, NA, NA, NA,…\n$ action_committee_name                <chr> \"Foreign Relations Committee\", NA…\n$ action_source_code                   <chr> \"0\", \"2\", \"2\", \"9\", \"2\", \"2\", \"2\"…\n$ action_source_name                   <chr> \"Senate\", \"House floor actions\", …\n$ action_text                          <chr> \"Received in the Senate and Read …\n$ action_type                          <chr> \"IntroReferral\", \"Floor\", \"Floor\"…\n$ action_time                          <time>       NA, 19:46:03, 19:46:02, 19…\n$ action_code                          <chr> NA, \"H38310\", \"H37300\", \"8000\", \"…\n$ votes                                <list> [<tbl_df[1 x 8]>], [<tbl_df[1 x …\n\n\nI’ll stop there for brevity’s sake, but you can find the code for extracting the full XML file here12."
  }
]