[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About me",
    "section": "",
    "text": "My interests include decision-making, governance institutions, and information systems, and particularly areas where these topics coincide.\nThis website is intended to showcase the kind of analysis I like to do, and how I like to do it.\nSome questions that are of particular interest to me:\n\nAre the structures and processes of policy-making institutions conducive to effective, informed, and equitable judgements?\nWhat factors in our society and policies perpetuate poverty?\nHow can public and private institutions foster an information system which enables society to develop a shared consensus of facts on issues central to public well-being?"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "20 min\n\n\n\n\n\n\nJul 14, 2022\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hi, I’m Mark.",
    "section": "",
    "text": "Welcome to my personal website! I am an analyst with a passion for behavioural science, R, and public policy. This website is for building a data analytics and visualization portfolio, and writing about policy and my research process."
  },
  {
    "objectID": "index.html#posts",
    "href": "index.html#posts",
    "title": "Hi, I’m Mark.",
    "section": "Posts",
    "text": "Posts"
  },
  {
    "objectID": "posts/parse-legislative-data.html",
    "href": "posts/parse-legislative-data.html",
    "title": "Parsing XML with R",
    "section": "",
    "text": "If you work with data regularly, you have probably used data formats like Excel spreadsheets, text files, relational databases and if you’re reading this potentially XML too. XML, or (e)Xtensible Markup Language, is a storage format designed for flexibly transmitting data1 which often leads to a bit of a hassle when trying to parse it for use in analytics. If you’re still reading, the good news is that this article should provide an understanding of XML and a set of steps for processing an XML file with R into a more analysis-friendly format.\nI’ll be using the US government’s congressional bill data as an example. As always the first step of data analysis is to check if any documentation exists and thankfully govinfo has provided some guidance for how the data is stored.\nTo follow along, you can download the sample XML file here. The sample bill (chosen only because it contains examples of important elements) is HR-391: Global Health Security Act of 2021 and the XML file contains information about its sponsors and cosponsors, votes on the bill, and the committees that considered it.\nHere’s a sample of the XML:\nAbove is an example of how votes recorded on the bill are stored. The <recordedVotes> container can have multiple <recordedVote> elements which describe a vote taken on the bill2."
  },
  {
    "objectID": "posts/parse-legislative-data.html#parse-the-simple-elements",
    "href": "posts/parse-legislative-data.html#parse-the-simple-elements",
    "title": "Parsing XML with R",
    "section": "Parse the simple elements",
    "text": "Parse the simple elements\nThe simple parts of the data to process are those which are already at the level of observation you want. In our case - at the bill level. These are typically the top-level nodes which only have one piece of data. To select only these nodes we can write a function like the one below:\n\nCode# Function to select singular child nodes from XML node\nxml_singular_nodes = function(xml_node){\n  # Return child nodes of current node\n  child_nodes = xml_children(xml_node)\n  # Select child nodes with 0 children\n  zero_length_child_nodes = child_nodes[xml_length(child_nodes) == 0]\n  \n  # Keep the nodes which are not empty strings\n  keep(zero_length_child_nodes, ~(xml_text(.) != \"\"))\n}\n\n(singular_nodes = xml_singular_nodes(bill_xml))\n\n{xml_nodeset (10)}\n [1] <billNumber>391</billNumber>\n [2] <createDate>2021-01-22T08:12:10Z</createDate>\n [3] <updateDate>2022-02-09T12:37:52Z</updateDate>\n [4] <originChamber>House</originChamber>\n [5] <billType>HR</billType>\n [6] <introducedDate>2021-01-21</introducedDate>\n [7] <congress>117</congress>\n [8] <constitutionalAuthorityStatementText><![CDATA[<pre>[Congressional Recor ...\n [9] <title>Global Health Security Act of 2021</title>\n[10] <version>1.0.0</version>\n\n\nNow with a nifty combination of as_list(), xml_name(), and flatten_dfc() we can convert the singular nodes into a single row of data.\n\nCodebill_df = as_list(singular_nodes) %>% \n  # as_list() doesn't retain element names so we set names ourselves\n  setNames(xml_name(singular_nodes)) %>% \n  flatten_dfc()\n\n\nWhich gives us a single row of data:\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhat about empty elements?\n\n\n\nNote that flatten_dfc() drops list elements which are empty (possibly through compact()?). This means our output varies based on each file’s contents. This is not an issue itself, but it is something to be wary of if you plan on combining multiple XML files.\n\n\nNow we have the bill title, when it was introduced, what type of bill it is, and which congress introduced it. I also want to include the data for actions, sponsors, committees, and votes, but these need to processed individually."
  },
  {
    "objectID": "posts/parse-legislative-data.html#parse-the-not-so-simple-elements",
    "href": "posts/parse-legislative-data.html#parse-the-not-so-simple-elements",
    "title": "Parsing XML with R",
    "section": "Parse the not-so-simple elements",
    "text": "Parse the not-so-simple elements\nThis is where the majority of the legwork is so if you can comfortably ignore5 some portion of the data, now’s a good time. There’s no point spending an hour trying to write a function for one particularly difficult bit of information only to realize you don’t need it anyway.\nFor brevity I will just go through actions and votes, but you can find the code for extracting the full XML file here6.\nActions\nWhat’s in the actions container?\n\nCode(actions_xml = xml_find_all(bill_xml, \"actions/item\"))\n\n{xml_nodeset (14)}\n [1] <item>\\n  <actionDate>2021-07-12</actionDate>\\n  <committees>\\n    <item ...\n [2] <item>\\n  <actionDate>2021-06-28</actionDate>\\n  <actionTime>19:46:03</a ...\n [3] <item>\\n  <actionDate>2021-06-28</actionDate>\\n  <actionTime>19:46:02</a ...\n [4] <item>\\n  <actionDate>2021-06-28</actionDate>\\n  <actionTime>19:46:02</a ...\n [5] <item>\\n  <actionDate>2021-06-28</actionDate>\\n  <actionTime>19:24:39</a ...\n [6] <item>\\n  <actionDate>2021-06-28</actionDate>\\n  <actionTime>15:20:02</a ...\n [7] <item>\\n  <actionDate>2021-06-28</actionDate>\\n  <actionTime>15:05:31</a ...\n [8] <item>\\n  <actionDate>2021-06-28</actionDate>\\n  <actionTime>15:05:26</a ...\n [9] <item>\\n  <actionDate>2021-06-28</actionDate>\\n  <actionTime>15:05:13</a ...\n[10] <item>\\n  <actionDate>2021-03-25</actionDate>\\n  <committees>\\n    <item ...\n[11] <item>\\n  <actionDate>2021-03-25</actionDate>\\n  <committees>\\n    <item ...\n[12] <item>\\n  <actionDate>2021-01-21</actionDate>\\n  <links/>\\n  <text>Refer ...\n[13] <item>\\n  <actionDate>2021-01-21</actionDate>\\n  <links/>\\n  <text>Intro ...\n[14] <item>\\n  <actionDate>2021-01-21</actionDate>\\n  <links/>\\n  <text>Intro ...\n\n\nSo this bill has 14 actions recorded on it. We can use as_list() to convert the XML to a list.\n\nCodeactions_list = as_list(actions_xml)\n\nglimpse(actions_list[[1]])\n\nList of 6\n $ actionDate  :List of 1\n  ..$ : chr \"2021-07-12\"\n $ committees  :List of 1\n  ..$ item:List of 2\n  .. ..$ systemCode:List of 1\n  .. ..$ name      :List of 1\n $ links       : list()\n $ sourceSystem:List of 2\n  ..$ code:List of 1\n  .. ..$ : chr \"0\"\n  ..$ name:List of 1\n  .. ..$ : chr \"Senate\"\n $ text        :List of 1\n  ..$ : chr \"Received in the Senate and Read twice and referred to the Committee on Foreign Relations.\"\n $ type        :List of 1\n  ..$ : chr \"IntroReferral\"\n\n\nIn the individual action container, we can see we have the type, text, and date of the action, a list of committees related to the action, and some elements which are singular and some which are not. To deal with this, we can write a function (or set of functions) like the ones below to process an action:\n\nCode# Function to flatten a list to dataframe columns and \n# rename the columns with a given prefix\nflatten_dfc_rename = function(list_to_flatten, \n                          name_prefix = \"prefix\"){\n  rename_with(flatten_dfc(list_to_flatten), ~str_c(name_prefix, \"_\", .))\n}\n\n# Parse actions from list to dataframe\nparse_action = function(action){\n  action %>% \n    # Flatten sourceSystem elements and rename them\n    modify_at(\"sourceSystem\", ~flatten_dfc_rename(.x, \"source\")) %>% \n    modify_at(\"committees\", function(committee){\n      map_dfr(committee, ~flatten_dfc_rename(.x, \"committee\"))\n    }) %>% \n    flatten_dfc() %>% \n    rename_with(.fn = ~str_c(\"action_\", .), .cols = -starts_with(\"action\")) %>% \n    janitor::clean_names()\n}\n\nparse_action(actions_list[[1]])\n\n# A tibble: 1 × 7\n  action_date action_committee_system_code action_committee_na… action_source_c…\n  <chr>       <chr>                        <chr>                <chr>           \n1 2021-07-12  ssfr00                       Foreign Relations C… 0               \n# … with 3 more variables: action_source_name <chr>, action_text <chr>,\n#   action_type <chr>\n\n\nUsing purrr’s map_*() functions, we can apply this function over all of the items:\n\nCode(actions_df = map_dfr(actions_list, parse_action)) %>% \n  glimpse()\n\nRows: 14\nColumns: 9\n$ action_date                  <chr> \"2021-07-12\", \"2021-06-28\", \"2021-06-28\",…\n$ action_committee_system_code <chr> \"ssfr00\", NA, NA, NA, NA, NA, NA, NA, NA,…\n$ action_committee_name        <chr> \"Foreign Relations Committee\", NA, NA, NA…\n$ action_source_code           <chr> \"0\", \"2\", \"2\", \"9\", \"2\", \"2\", \"2\", \"2\", \"…\n$ action_source_name           <chr> \"Senate\", \"House floor actions\", \"House f…\n$ action_text                  <chr> \"Received in the Senate and Read twice an…\n$ action_type                  <chr> \"IntroReferral\", \"Floor\", \"Floor\", \"Floor…\n$ action_time                  <chr> NA, \"19:46:03\", \"19:46:02\", \"19:46:02\", \"…\n$ action_code                  <chr> NA, \"H38310\", \"H37300\", \"8000\", \"H30000\",…\n\n\nNow if you’re processing a large amount of these data, you may want to be explicit about the data types expected in each column. This is vital when we want to unnest() the actions data and combine many bills’ actions into an actions-level dataset. You can do this using type_convert() , notice the change in column types from the output above.\n\nCode(actions_df = type_convert(actions_df,\n                          col_types = cols(\n                            action_date = col_date(), \n                            action_time = col_time(),\n                            action_committee_systemCode = col_character(), \n                            action_committee_name = col_character(), \n                            action_source_code = col_character(),\n                            action_source_name = col_character(),\n                            action_text = col_character(), \n                            action_type = col_character(), \n                            action_code = col_character()\n                            )\n                          )) %>% \n  glimpse()\n\nRows: 14\nColumns: 9\n$ action_date                  <date> 2021-07-12, 2021-06-28, 2021-06-28, 2021…\n$ action_committee_system_code <chr> \"ssfr00\", NA, NA, NA, NA, NA, NA, NA, NA,…\n$ action_committee_name        <chr> \"Foreign Relations Committee\", NA, NA, NA…\n$ action_source_code           <chr> \"0\", \"2\", \"2\", \"9\", \"2\", \"2\", \"2\", \"2\", \"…\n$ action_source_name           <chr> \"Senate\", \"House floor actions\", \"House f…\n$ action_text                  <chr> \"Received in the Senate and Read twice an…\n$ action_type                  <chr> \"IntroReferral\", \"Floor\", \"Floor\", \"Floor…\n$ action_time                  <time>       NA, 19:46:03, 19:46:02, 19:46:02, …\n$ action_code                  <chr> NA, \"H38310\", \"H37300\", \"8000\", \"H30000\",…\n\n\nTo add these actions data as a list column to bill_df we can simply use dollar assignment.\n\nCodebill_df$actions = list(actions_df)\n\nglimpse(bill_df)\n\nRows: 1\nColumns: 11\n$ billNumber                           <chr> \"391\"\n$ createDate                           <chr> \"2021-01-22T08:12:10Z\"\n$ updateDate                           <chr> \"2022-02-09T12:37:52Z\"\n$ originChamber                        <chr> \"House\"\n$ billType                             <chr> \"HR\"\n$ introducedDate                       <chr> \"2021-01-21\"\n$ congress                             <chr> \"117\"\n$ constitutionalAuthorityStatementText <chr> \"<pre>[Congressional Record Volum…\n$ title                                <chr> \"Global Health Security Act of 20…\n$ version                              <chr> \"1.0.0\"\n$ actions                              <list> [<tbl_df[14 x 9]>]\n\n\nThe remaining sections will be following the same process for different elements, but it can be boiled down to these steps:\n\nExplore the structure\n\n\nGo through any available documentation, and when you read in the XML file you can use functions like xmlParse(), xml_structure(), and xml_contents() .\n\n\nDefine the output\n\n\nConsider what you want the output to look like and think about how it needs to be transformed to match this target.\n\n\n\nProcess a single element (write a function if it gets too complicated)\n\n\nGet one element into the form you want. Writing functions can help you think through the data transformations being applied and make your code easier to read.\n\n\nApply to all elements\n\n\nFocus on processing of the entire file (or the subset of the file you’re interested in). You might want an XML file to return a single row, a single column, or a dataframe of size \\(n\\times k\\). Once you have a single file returned in the format you want, you can combine the outputs of multiple files.\n\n\n\n\n\n\n\nFind the exceptions\n\n\n\nLastly, you will likely run into situations where a node which only seemed to contain a single piece of data has a different structure with multiple sub-elements for other files. This will happen, you’ll go back to the drawing board, design more flexibility in your functions, and understand how process either format.\n\n\nVotes\nVotes are particularly interesting because it provides a more discrete measure of our representatives’ behaviour. Individual votes are stored in the <recordedVotes> container. We can access child elements in XML using a forward slash (this uses a language called XPATH).\n\nCode(bill_recorded_vote_nodes = xml_find_all(bill_xml, \"recordedVotes/recordedVote\")) %>% \n  xml_contents()\n\n{xml_nodeset (7)}\n[1] <rollNumber>188</rollNumber>\n[2] <url>https://clerk.house.gov/evs/2021/roll188.xml</url>\n[3] <fullActionName>Final Passage Under Suspension of the Rules Results</full ...\n[4] <chamber>House</chamber>\n[5] <congress>117</congress>\n[6] <date>2021-06-28T23:46:02Z</date>\n[7] <sessionNumber>1</sessionNumber>\n\n\nYou may have spotted why votes are interesting elements to parse because inside the <url> element we find another XML file!7 Before we dive into that can of worms, I’ll convert the top-level nodes to a list and flatten it into columns. Note we use map_dfr() with votes_list because there could be multiple vote objects.\n\nCode# Coerce nodes to list\nrecorded_votes_list = as_list(bill_recorded_vote_nodes)\n\n(recorded_votes_df = map_dfr(recorded_votes_list, flatten_dfc)) %>% \n  glimpse()\n\nRows: 1\nColumns: 7\n$ rollNumber     <chr> \"188\"\n$ url            <chr> \"https://clerk.house.gov/evs/2021/roll188.xml\"\n$ fullActionName <chr> \"Final Passage Under Suspension of the Rules Results\"\n$ chamber        <chr> \"House\"\n$ congress       <chr> \"117\"\n$ date           <chr> \"2021-06-28T23:46:02Z\"\n$ sessionNumber  <chr> \"1\"\n\n\nNow we want to get the vote roll XML file, so we go back to read_xml() .\n\nCode(vote_roll_xml = read_xml(recorded_votes_df$url))\n\n{xml_document}\n<rollcall-vote>\n[1] <vote-metadata>\\n  <majority>D</majority>\\n  <congress>117</congress>\\n   ...\n[2] <vote-data>\\n  <recorded-vote>\\n    <legislator name-id=\"A000370\" sort-fi ...\n\n\nThere are two main nodes - <vote-metadata> and <vote-data>. How many elements does each node have and what do the structures for these look like?\n\nCode(vote_roll_children = xml_children(vote_roll_xml)) %>% \n  map(xml_contents)\n\n[[1]]\n{xml_nodeset (13)}\n [1] <majority>D</majority>\n [2] <congress>117</congress>\n [3] <session>1st</session>\n [4] <chamber>U.S. House of Representatives</chamber>\n [5] <rollcall-num>188</rollcall-num>\n [6] <legis-num>H R 391</legis-num>\n [7] <vote-question>On Motion to Suspend the Rules and Pass, as Amended</vote ...\n [8] <vote-type>2/3 YEA-AND-NAY</vote-type>\n [9] <vote-result>Passed</vote-result>\n[10] <action-date>28-Jun-2021</action-date>\n[11] <action-time time-etz=\"19:42\">7:42 PM</action-time>\n[12] <vote-desc>Global Health Security Act</vote-desc>\n[13] <vote-totals>\\n  <totals-by-party-header>\\n    <party-header>Party</part ...\n\n[[2]]\n{xml_nodeset (430)}\n [1] <recorded-vote>\\n  <legislator name-id=\"A000370\" sort-field=\"Adams\" unac ...\n [2] <recorded-vote>\\n  <legislator name-id=\"A000055\" sort-field=\"Aderholt\" u ...\n [3] <recorded-vote>\\n  <legislator name-id=\"A000371\" sort-field=\"Aguilar\" un ...\n [4] <recorded-vote>\\n  <legislator name-id=\"A000372\" sort-field=\"Allen\" unac ...\n [5] <recorded-vote>\\n  <legislator name-id=\"A000376\" sort-field=\"Allred\" una ...\n [6] <recorded-vote>\\n  <legislator name-id=\"A000369\" sort-field=\"Amodei\" una ...\n [7] <recorded-vote>\\n  <legislator name-id=\"A000377\" sort-field=\"Armstrong\"  ...\n [8] <recorded-vote>\\n  <legislator name-id=\"A000375\" sort-field=\"Arrington\"  ...\n [9] <recorded-vote>\\n  <legislator name-id=\"A000148\" sort-field=\"Auchincloss ...\n[10] <recorded-vote>\\n  <legislator name-id=\"A000378\" sort-field=\"Axne\" unacc ...\n[11] <recorded-vote>\\n  <legislator name-id=\"B001291\" sort-field=\"Babin\" unac ...\n[12] <recorded-vote>\\n  <legislator name-id=\"B001298\" sort-field=\"Bacon\" unac ...\n[13] <recorded-vote>\\n  <legislator name-id=\"B001307\" sort-field=\"Baird\" unac ...\n[14] <recorded-vote>\\n  <legislator name-id=\"B001306\" sort-field=\"Balderson\"  ...\n[15] <recorded-vote>\\n  <legislator name-id=\"B001299\" sort-field=\"Banks\" unac ...\n[16] <recorded-vote>\\n  <legislator name-id=\"B001282\" sort-field=\"Barr\" unacc ...\n[17] <recorded-vote>\\n  <legislator name-id=\"B001300\" sort-field=\"Barragan\" u ...\n[18] <recorded-vote>\\n  <legislator name-id=\"B001270\" sort-field=\"Bass\" unacc ...\n[19] <recorded-vote>\\n  <legislator name-id=\"B001281\" sort-field=\"Beatty\" una ...\n[20] <recorded-vote>\\n  <legislator name-id=\"B000668\" sort-field=\"Bentz\" unac ...\n...\n\n\nOne node contains the aggregated vote information, while <vote-data> contains the legislator-level vote data. Let’s try to parse the legislator-level data first.\n\nCode(vote_data = xml_find_all(vote_roll_xml, \"vote-data\"))\n\n{xml_nodeset (1)}\n[1] <vote-data>\\n  <recorded-vote>\\n    <legislator name-id=\"A000370\" sort-fi ...\n\n\nHere is the XML for a single legislator’s vote:\n\nCodexml_child(vote_data)\n\n{xml_node}\n<recorded-vote>\n[1] <legislator name-id=\"A000370\" sort-field=\"Adams\" unaccented-name=\"Adams\"  ...\n[2] <vote>Yea</vote>\n\n\nWith a similar combination of as_list() , flatten_dfr(), and unnest() we can flatten the XML into one row per legislator\n\nCode(vote_roll_flattened = vote_data %>% \n  as_list() %>% \n  flatten_dfr() %>% \n    unnest(everything()))\n\n# A tibble: 430 × 2\n   legislator  vote \n   <chr>       <chr>\n 1 Adams       Yea  \n 2 Aderholt    Nay  \n 3 Aguilar     Yea  \n 4 Allen       Nay  \n 5 Allred      Yea  \n 6 Amodei      Yea  \n 7 Armstrong   Yea  \n 8 Arrington   Nay  \n 9 Auchincloss Yea  \n10 Axne        Yea  \n# … with 420 more rows\n\n\nBut we lose all the attributes! And name-id looked particularly useful. We’ll need to extract the attributes before we flatten the data. Let’s take another look at the legislators structure.\n\nCodevote_legislators = vote_data %>% \n  xml_find_all(\"recorded-vote\")\n\n(legislators_list = as_list(vote_legislators))[1] %>% \n  glimpse()\n\nList of 1\n $ :List of 2\n  ..$ legislator:List of 1\n  .. ..$ : chr \"Adams\"\n  .. ..- attr(*, \"name-id\")= chr \"A000370\"\n  .. ..- attr(*, \"sort-field\")= chr \"Adams\"\n  .. ..- attr(*, \"unaccented-name\")= chr \"Adams\"\n  .. ..- attr(*, \"party\")= chr \"D\"\n  .. ..- attr(*, \"state\")= chr \"NC\"\n  .. ..- attr(*, \"role\")= chr \"legislator\"\n  ..$ vote      :List of 1\n  .. ..$ : chr \"Yea\"\n\n\nThe legislator element has all the attributes, while the vote element only has a value. We want to extract the attributes only for legislator using map() to apply map_at() on each legislator element and extract the attributes from each while retaining the value in vote. It can often feel like you’re getting lost in a list of lists, but with some experimentation you’ll be able to find your way back to the surface.\n\nCode(legislator_vote_df = legislators_list %>% \n    # Modify one level deeper using map_at to target legislator elements\n    map(map_at, \"legislator\", attributes) %>% \n    map_dfr(flatten_dfc))\n\n# A tibble: 430 × 7\n   `name-id` `sort-field` `unaccented-name` party state role       vote \n   <chr>     <chr>        <chr>             <chr> <chr> <chr>      <chr>\n 1 A000370   Adams        Adams             D     NC    legislator Yea  \n 2 A000055   Aderholt     Aderholt          R     AL    legislator Nay  \n 3 A000371   Aguilar      Aguilar           D     CA    legislator Yea  \n 4 A000372   Allen        Allen             R     GA    legislator Nay  \n 5 A000376   Allred       Allred            D     TX    legislator Yea  \n 6 A000369   Amodei       Amodei            R     NV    legislator Yea  \n 7 A000377   Armstrong    Armstrong         R     ND    legislator Yea  \n 8 A000375   Arrington    Arrington         R     TX    legislator Nay  \n 9 A000148   Auchincloss  Auchincloss       D     MA    legislator Yea  \n10 A000378   Axne         Axne              D     IA    legislator Yea  \n# … with 420 more rows\n\n\nNow we have a table of legislator voting data! But what about the <vote-metadata>?\n\nCode(vote_metadata = xml_find_all(vote_roll_xml, \"vote-metadata\")) %>% \n  xml_contents()\n\n{xml_nodeset (13)}\n [1] <majority>D</majority>\n [2] <congress>117</congress>\n [3] <session>1st</session>\n [4] <chamber>U.S. House of Representatives</chamber>\n [5] <rollcall-num>188</rollcall-num>\n [6] <legis-num>H R 391</legis-num>\n [7] <vote-question>On Motion to Suspend the Rules and Pass, as Amended</vote ...\n [8] <vote-type>2/3 YEA-AND-NAY</vote-type>\n [9] <vote-result>Passed</vote-result>\n[10] <action-date>28-Jun-2021</action-date>\n[11] <action-time time-etz=\"19:42\">7:42 PM</action-time>\n[12] <vote-desc>Global Health Security Act</vote-desc>\n[13] <vote-totals>\\n  <totals-by-party-header>\\n    <party-header>Party</part ...\n\n\nEverything other than the <vote-totals> element is singular so we can get that out of the way the same way as before:\n\nCodevote_singular_nodes = xml_singular_nodes(vote_metadata)\n\n(vote_df = as_list(vote_singular_nodes) %>% \n  # as_list() doesn't retain element names so we set names ourselves\n  setNames(xml_name(vote_singular_nodes)) %>% \n  flatten_dfc()) %>% \n  glimpse()\n\nRows: 1\nColumns: 12\n$ majority        <chr> \"D\"\n$ congress        <chr> \"117\"\n$ session         <chr> \"1st\"\n$ chamber         <chr> \"U.S. House of Representatives\"\n$ `rollcall-num`  <chr> \"188\"\n$ `legis-num`     <chr> \"H R 391\"\n$ `vote-question` <chr> \"On Motion to Suspend the Rules and Pass, as Amended\"\n$ `vote-type`     <chr> \"2/3 YEA-AND-NAY\"\n$ `vote-result`   <chr> \"Passed\"\n$ `action-date`   <chr> \"28-Jun-2021\"\n$ `action-time`   <chr> \"7:42 PM\"\n$ `vote-desc`     <chr> \"Global Health Security Act\"\n\n\nThe <vote-totals> are a bit of a unique little element, with 3 different types of nodes.\n\nCode(vote_totals = xml_find_all(vote_metadata, \"vote-totals\")) %>% \n  xml_contents()\n\n{xml_nodeset (5)}\n[1] <totals-by-party-header>\\n  <party-header>Party</party-header>\\n  <yea-he ...\n[2] <totals-by-party>\\n  <party>Republican</party>\\n  <yea-total>90</yea-tota ...\n[3] <totals-by-party>\\n  <party>Democratic</party>\\n  <yea-total>217</yea-tot ...\n[4] <totals-by-party>\\n  <party>Independent</party>\\n  <yea-total>0</yea-tota ...\n[5] <totals-by-vote>\\n  <total-stub>Totals</total-stub>\\n  <yea-total>307</ye ...\n\n\nThis is another opportunity for us to be choosy with our data. The first node is table headers, which we don’t need because the elements are tagged anyway. From these, we really only need the <totals-by-party> nodes as long as the totals of which agree with <totals-by-vote> , which is worth checking.\n\nCode(vote_totals_by_party = xml_find_all(vote_totals, \"totals-by-party\"))\n(totals_by_vote = xml_find_all(vote_totals, \"totals-by-vote\")) %>% \n  xml_contents()\n\n\n\n{xml_nodeset (3)}\n[1] <totals-by-party>\\n  <party>Republican</party>\\n  <yea-total>90</yea-tota ...\n[2] <totals-by-party>\\n  <party>Democratic</party>\\n  <yea-total>217</yea-tot ...\n[3] <totals-by-party>\\n  <party>Independent</party>\\n  <yea-total>0</yea-tota ...\n\n\n{xml_nodeset (5)}\n[1] <total-stub>Totals</total-stub>\n[2] <yea-total>307</yea-total>\n[3] <nay-total>112</nay-total>\n[4] <present-total>0</present-total>\n[5] <not-voting-total>11</not-voting-total>\n\n\n\n\nOnce we have our nodeset (which at last are all singular), we use same listing, mapping, and flattening…or lappening as absolutely no one calls it.\n\nCode(party_vote_totals_df = vote_totals_by_party %>% \n  as_list() %>% \n  map_dfr(flatten_dfc) %>% \n    type_convert())\n\n# A tibble: 3 × 5\n  party       `yea-total` `nay-total` `present-total` `not-voting-total`\n  <chr>             <dbl>       <dbl>           <dbl>              <dbl>\n1 Republican           90         112               0                  9\n2 Democratic          217           0               0                  2\n3 Independent           0           0               0                  0\n\n\nNow that we have all of our vote data wrangled from the thorny grasp of XML, we can put it all together.\n\nCode(vote_roll_df = vote_df %>% \n  mutate(legislator_votes = list(legislator_vote_df),\n         party_votes = list(party_vote_totals_df)) %>% \n    janitor::clean_names()) %>% \n  glimpse()\n\nRows: 1\nColumns: 14\n$ majority         <chr> \"D\"\n$ congress         <chr> \"117\"\n$ session          <chr> \"1st\"\n$ chamber          <chr> \"U.S. House of Representatives\"\n$ rollcall_num     <chr> \"188\"\n$ legis_num        <chr> \"H R 391\"\n$ vote_question    <chr> \"On Motion to Suspend the Rules and Pass, as Amended\"\n$ vote_type        <chr> \"2/3 YEA-AND-NAY\"\n$ vote_result      <chr> \"Passed\"\n$ action_date      <chr> \"28-Jun-2021\"\n$ action_time      <chr> \"7:42 PM\"\n$ vote_desc        <chr> \"Global Health Security Act\"\n$ legislator_votes <list> [<tbl_df[430 x 7]>]\n$ party_votes      <list> [<tbl_df[3 x 5]>]\n\n\nAnd we continue to stack this Russian doll of data from the legislator-level to the vote-level…\n\nCode(recorded_votes_df = recorded_votes_df %>% \n  mutate(vote_roll = list(vote_roll_df))) %>% \n  glimpse()\n\nRows: 1\nColumns: 8\n$ rollNumber     <chr> \"188\"\n$ url            <chr> \"https://clerk.house.gov/evs/2021/roll188.xml\"\n$ fullActionName <chr> \"Final Passage Under Suspension of the Rules Results\"\n$ chamber        <chr> \"House\"\n$ congress       <chr> \"117\"\n$ date           <chr> \"2021-06-28T23:46:02Z\"\n$ sessionNumber  <chr> \"1\"\n$ vote_roll      <list> [<tbl_df[1 x 14]>]\n\n\n…all the way until we’ve gotten back to the bill-level.\n\nCodebill_df$votes = list(recorded_votes_df)\n\nglimpse(bill_df)\n\nRows: 1\nColumns: 12\n$ billNumber                           <chr> \"391\"\n$ createDate                           <chr> \"2021-01-22T08:12:10Z\"\n$ updateDate                           <chr> \"2022-02-09T12:37:52Z\"\n$ originChamber                        <chr> \"House\"\n$ billType                             <chr> \"HR\"\n$ introducedDate                       <chr> \"2021-01-21\"\n$ congress                             <chr> \"117\"\n$ constitutionalAuthorityStatementText <chr> \"<pre>[Congressional Record Volum…\n$ title                                <chr> \"Global Health Security Act of 20…\n$ version                              <chr> \"1.0.0\"\n$ actions                              <list> [<tbl_df[14 x 9]>]\n$ votes                                <list> [<tbl_df[1 x 8]>]"
  }
]