---
title: "Parsing XML with R, using congressional legislative data"
author: "Mark"
---

```{r}
#| label: setup
#| message: false
library(extrafont)
library(reactable)

source("https://github.com/MokeEire/my-reps/raw/master/R/parsing_functions.R")
bill_xml_link = "https://www.govinfo.gov/bulkdata/BILLSTATUS/117/hr/BILLSTATUS-117hr391.xml"
bill_xml_file = read_xml(bill_xml_link)
```

```{r}
#| label: df-print-fct
#| include: false

knit_print.data.frame = function(x, ...){
  knitr::knit_print(
    reactable(x,
              compact = T, 
              resizable = T,
              ),
    ...
    )
}
```

If you work with data regularly, you have probably used a plethora of data input formats, from Excel spreadsheets and text files to relational databases and potentially XML. (e)Xtensible Markup Language is a storage type designed for flexibly storing and transmitting data[^1]. This flexibility often leads to a bit of a hassle when trying to parse XML data. If you're still reading, the good news is that this article should provide an understanding of XML and a set of steps for processing an XML file with R into a more analysis-friendly format.

[^1]: [Wikipedia](https://en.wikipedia.org/wiki/XML) for the curious. Don't miss the drama about Microsoft's "vociferous protests" as one of the co-editors started working with Netscape.

::: {.callout-tip appearance="simple"}
## In this post you will learn to:

-   Load and parse XML files in R using the [`{xml2}`](https://xml2.r-lib.org/) package

-   Explore the structure of XML documents
:::

The first step is always to check the data documentation[^2]. In this post I'll be using the US government's [congressional bill data](https://www.govinfo.gov/bulkdata/BILLSTATUS). To follow along, you can download the [individual XML file](https://www.govinfo.gov/bulkdata/BILLSTATUS/117/hr/BILLSTATUS-117hr391.xml "HR-391: Global Health Security Act of 2021"), while you can find the bulk data [here](https://www.govinfo.gov/bulkdata/BILLSTATUS).

[^2]: Sorry to all whose documentation is:\
    "We don't have anything like that, but you can ask \[Impossibly busy data engineer\], they know everything you need."

The XML file contains information about HR-391: Global Health Security Act of 2021 like its sponsors and cosponsors, votes on the bill, and the committees that considered it. Here's a sample of the XML:

```{r}
#| layout-nrow: 1
#| layout-ncol: 2
#| class-output: code-block-h
#| column: page-inset-shaded
#| echo: false
(example_node = xml_find_first(bill_xml_file, "//bill/recordedVotes")) %>% 
  xml_structure()

xml_child(example_node)
```

Above is an example of how votes recorded on the bill are stored. The `<recordedVotes>` container can have multiple `<recordedVote>` elements which describe a vote taken on the bill[^3].

[^3]: We can (and later I do) go deeper here and extract the roll's XML file to get individual representatives' votes.

# Read XML with R

We'll need to load the {xml2} package to read in our XML file. I also load the {tidyverse} package because it's generally exceedingly useful.

```{r}
#| code-fold: show
library(tidyverse)
library(xml2)

bill_xml_file = read_xml("https://www.govinfo.gov/bulkdata/BILLSTATUS/117/hr/BILLSTATUS-117hr391.xml")
```

`read_xml()` returns an `xml_document`[^4] object. With this, we can look at the bill's top level nodes.

[^4]: `xml_document` is one of the "key classes" used in the `{xml2}` library, the others being `xml_node` (a single node), and `xml_nodeset` (a set of nodes).

```{r}
#| code-fold: show
# Look at the contents
xml_contents(bill_xml_file)
```

In this case it's actually more useful to look at the `<bill>` element which is a child node of our XML document[^5], which is what `xml_child()` is for.

[^5]: I will confess I'm not quite sure why this is the case, nor do I particularly understand what `<dublinCore>` is (though prevailing theories suggest some kind of document schema or a new metal genre originating from my home of Dublin).

```{r}
#| code-fold: show
#| label: xml-bill-child
#| code-overflow: wrap
# Return child nodes named bill
xml_child(bill_xml_file, "bill")
```

which offers us a view of how bills pass through congress and how congress members act in the process. Bills are stored in [XML](https://en.wikipedia.org/wiki/XML) which is really handy for storing information but less helpful for analysis (or at least seems so to me).

In this post, I will show you how to read in a raw XML file and parse it into a dataframe containing nested dataframes where necessary.

::: panel-tabset
## Raw XML

```{r}
#| echo: false
xml_child(bill_xml_file, "bill")
```

## to a formatted dataframe

Containing nested dataframes for elements which are at different levels of observation:

```{r}
#| echo: false
#| message: false
#| column: page
example_bill_df = extract_bill_status(bill_xml_link, log_types = "console")

example_bill_df %>% 
  select(
    -bill_id, -constitutionalAuthorityStatementText, -where(is_list)
  ) %>% 
  reactable::reactable(
    theme = moke_rt(),
    compact = T,
    resizable = T,
    columns = list(
      "billNumber" = colDef(width = 100),
      "billType" = colDef(width = 100),
      "congress" = colDef(width = 100),
      "version" = colDef(width = 100),
      "createDate" = colDef(width = 100, format = colFormat(date = T)),
      "updateDate" = colDef(width = 100, format = colFormat(date = T)),
      "introducedDate" = colDef(format = colFormat(date = T)),
      "latestAction_actionDate" = colDef(format = colFormat(date = T))
    )
  )
```

::: panel-tabset
## Committees

Committees contains two list columns with dataframes - `committee_activities` and `subcommittee_activities`.

```{r}
#| echo: false
#| column: page
reactable::reactable(
  rename_with(unnest(example_bill_df["committees"], cols = c(committees)), 
              ~str_to_title(str_replace_all(., "_", " "))),
  theme = moke_rt(),
    compact = T,
    resizable = T,
    wrap = F
  )
```

## Votes

Votes contains one list column with a dataframe - `vote_roll`.

```{r}
#| echo: false
#| column: page
reactable(
  rename_with(unnest(example_bill_df["votes"], cols = c(votes)), 
              ~str_to_title(str_replace_all(., "_", " "))),
  theme = moke_rt(),
    compact = T,
    resizable = T,
    wrap = F
  )
```

## Actions

```{r}
#| echo: false
#| column: page
reactable(
  rename_with(unnest(example_bill_df["actions"], cols = c(actions)), 
              ~str_to_title(str_remove_all(., "action_?"))),
  theme = moke_rt(),
    compact = T,
    resizable = T,
    wrap = F,
  pagination = F,
  height = "320px"
  )
```

## Sponsors

```{r}
#| echo: false
#| column: page
reactable(
  rename_with(unnest(example_bill_df["sponsors"], cols = c(sponsors)), 
              ~str_to_title(str_replace_all(., "sponsor_", ""))),
  theme = moke_rt(),
    compact = T,
    resizable = T,
    wrap = F
  )
```

## Cosponsors

```{r}
#| echo: false
#| column: page
reactable(
  rename_with(unnest(example_bill_df["cosponsors"], cols = c(cosponsors)), 
              ~str_to_title(str_remove_all(., "cosponsor_"))),
  theme = moke_rt(),
    compact = T,
    resizable = T,
  pagination = F,
  height = "320px"
  )
```
:::
:::

# The Process

## Understanding the structure

As mentioned at the outset, we will be using [govinfo's Bill Status data](https://www.govinfo.gov/bulkdata/BILLSTATUS)[^6] and parsing the data into a dataframe format which can be more easily manipulated. To explore the structure of the legislative data, I selected a bill which contained information on committees, actions, votes, and cosponsors.

[^6]: Some helpful resources for navigating this data:\
    <https://github.com/usgpo/bulk-data>\
    <https://www.govinfo.gov/help/bills>

```{r}
#| label: read-xml
#| code-fold: show
(bill_xml_file = read_xml("https://www.govinfo.gov/bulkdata/BILLSTATUS/117/hr/BILLSTATUS-117hr391.xml"))
```

`read_xml()` returns an `xml_document`[^7] object which shows us the top level nodes when called in the console. Now let's take a look at the full structure of the file.

[^7]: `xml_document` is one of the "key classes" used in the `{xml2}` library, the others being `xml_node` (a single node), and `xml_nodeset` (a set of nodes).

```{r}
#| class-output: code-block-h
#| code-fold: show
xml_structure(bill_xml_file)

```

This output shows how nested elements are stored e.g. `<committees>` contains elements for committees associated with the bill, and within each committee there may be a `<subcommittees>` element to record subcommittee activity too. It is this nested structure which makes XML a useful storage type for legislative information.

Using R's list columns, we can have all this information in a single object and use `unnest()` to change the level of detail.

To get a good understanding of what is in the data, it is usually a good idea to read through [the documentation](https://github.com/usgpo/bill-status/blob/main/BILLSTATUS-XML_User_User-Guide.md#21elements) first. To explore the contents of XML files, these functions are incredibly helpful:

-   [`xml_structure()`](https://xml2.r-lib.org/reference/xml_structure.html)

-   [`xml_contents()`](https://xml2.r-lib.org/reference/xml_children.html)

-   [`xml_children()`](https://xml2.r-lib.org/reference/xml_children.html) / `xml_child()` - return a nodeset of child nodes or a specific node

Within the `billStatus` document, we want to select the `<bill>` child node which is the *actual* parent node of our data. We can use `xml_child()` to select this node:

```{r}
#| label: select-bill
#| code-fold: show
(bill_node = xml_child(bill_xml_file, "bill"))
```

::: callout-note
You can check the length of your node using `xml_length()`
:::

```{r}
#| label: xml-length
#| code-fold: show
xml_length(bill_node)
```

Now we can see the topline elements of the data. We have identifying attributes like the bill number, type, and the congress it was introduced in. We also have information on how legislators interacted with the bill like the bill's sponsors and cosponsors, which committees were involved in its passage, votes taken on the bill, and a variety of other attributes listed above.

## From XML to dataframe

Now that we have the XML data loaded, we want to parse it into a dataframe (or tibble) so we can use it in an analysis. This requires a bit of strategy and consideration of how you want to structure your data. I am structuring the data at the bill-level i.e. one row per bill.

### Singular vs. Non-singular nodes

For nodes like `<billNumber>` and `<introducedDate>`, we only have one element per bill but other elements like `<committees>` and `<actions>` there might be dozens of elements per bill.

We can check the length of each node to determine if they only have one element

```{r}
#| label: explore-fcts
(bill_node_lengths = xml_length(xml_children(bill_node)))
```

Using this, we can look at nodes which have zero length and which do not.

::: panel-tabset
### Singular Nodes

```{r}
#| label: singular-nodes
#| class-output: code-block-h
#| code-fold: show
(singular_nodes = xml_children(bill_node)[bill_node_lengths == 0])
```

### Non-singular Nodes

```{r}
#| label: nonsingular-nodes
#| code-fold: show
#| class-output: code-block-h
(nonsingular_nodes = xml_children(bill_node)[bill_node_lengths > 0])
```
:::

Now with a nifty combination of `as_list()`, `xml_name()`, and `flatten_dfc()` we can convert the singular nodes into a single row of data.

```{r}
#| label: singular-nodes-df
#| column: page
(singular_nodes_df = as_list(singular_nodes) %>% 
  setNames(xml_name(singular_nodes)) %>% 
  flatten_dfc()) %>% 
  reactable(theme = moke_rt(),
            columns = list(
              "constitutionalAuthorityStatementText" = colDef(show=F),
              "createDate" = colDef(format = colFormat(date = T), width = 100),
              "updateDate" = colDef(format = colFormat(date = T), width = 100),
              "introducedDate" = colDef(format = colFormat(date = T)),
              "congress" = colDef(width = 100),
              "version" = colDef(width = 100),
              "billNumber" = colDef(width = 100),
              "billType" = colDef(width = 100)
            ))
```

Note that `flatten_dfc()` drops list elements which are empty (possibly through `compact()`?). Unfortunately, `as_list()` doesn't retain the element's name so we need to set the names ourselves.

```{r}
#| label: singular-nodes-str
#| class-output: code-block-h
as_list(singular_nodes) %>% 
  str()

```

------------------------------------------------------------------------

# Other helpful articles

Here are some of the helpful articles I came across in the course of writing this:

[From XML to Excel for Data Analysis](https://towardsdatascience.com/from-xml-to-excel-for-data-analysis-ac0c0c765b7d "Introduction to Processing XML In Python")

# Session Info

```{r}
#| label: session-info
sessioninfo::session_info("loaded")
```
